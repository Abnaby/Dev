/* AUTOGENERATED FILE. DO NOT EDIT. */
#include <string.h>
#include <stdlib.h>
#include <setjmp.h>
#include "cmock.h"
#include "mock_can_lib.h"

static const char* CMockString_CANBitRateSet = "CANBitRateSet";
static const char* CMockString_CANBitTimingGet = "CANBitTimingGet";
static const char* CMockString_CANBitTimingSet = "CANBitTimingSet";
static const char* CMockString_CANDisable = "CANDisable";
static const char* CMockString_CANEnable = "CANEnable";
static const char* CMockString_CANErrCntrGet = "CANErrCntrGet";
static const char* CMockString_CANInit = "CANInit";
static const char* CMockString_CANIntClear = "CANIntClear";
static const char* CMockString_CANIntDisable = "CANIntDisable";
static const char* CMockString_CANIntEnable = "CANIntEnable";
static const char* CMockString_CANIntRegister = "CANIntRegister";
static const char* CMockString_CANIntStatus = "CANIntStatus";
static const char* CMockString_CANIntUnregister = "CANIntUnregister";
static const char* CMockString_CANMessageClear = "CANMessageClear";
static const char* CMockString_CANMessageGet = "CANMessageGet";
static const char* CMockString_CANMessageSet = "CANMessageSet";
static const char* CMockString_CANRetryGet = "CANRetryGet";
static const char* CMockString_CANRetrySet = "CANRetrySet";
static const char* CMockString_CANStatusGet = "CANStatusGet";
static const char* CMockString_bAutoRetry = "bAutoRetry";
static const char* CMockString_bClrPendingInt = "bClrPendingInt";
static const char* CMockString_eIntStsReg = "eIntStsReg";
static const char* CMockString_eMsgType = "eMsgType";
static const char* CMockString_eStatusReg = "eStatusReg";
static const char* CMockString_pfnHandler = "pfnHandler";
static const char* CMockString_psClkParms = "psClkParms";
static const char* CMockString_psMsgObject = "psMsgObject";
static const char* CMockString_pui32RxCount = "pui32RxCount";
static const char* CMockString_pui32TxCount = "pui32TxCount";
static const char* CMockString_ui32Base = "ui32Base";
static const char* CMockString_ui32BitRate = "ui32BitRate";
static const char* CMockString_ui32IntClr = "ui32IntClr";
static const char* CMockString_ui32IntFlags = "ui32IntFlags";
static const char* CMockString_ui32ObjID = "ui32ObjID";
static const char* CMockString_ui32SourceClock = "ui32SourceClock";

typedef struct _CMOCK_CANBitTimingGet_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  uint32 Expected_ui32Base;
  tCANBitClkParms* Expected_psClkParms;
  int Expected_psClkParms_Depth;
  char ReturnThruPtr_psClkParms_Used;
  tCANBitClkParms const* ReturnThruPtr_psClkParms_Val;
  size_t ReturnThruPtr_psClkParms_Size;
  char IgnoreArg_ui32Base;
  char IgnoreArg_psClkParms;

} CMOCK_CANBitTimingGet_CALL_INSTANCE;

typedef struct _CMOCK_CANBitTimingSet_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  uint32 Expected_ui32Base;
  tCANBitClkParms* Expected_psClkParms;
  int Expected_psClkParms_Depth;
  char ReturnThruPtr_psClkParms_Used;
  tCANBitClkParms const* ReturnThruPtr_psClkParms_Val;
  size_t ReturnThruPtr_psClkParms_Size;
  char IgnoreArg_ui32Base;
  char IgnoreArg_psClkParms;

} CMOCK_CANBitTimingSet_CALL_INSTANCE;

typedef struct _CMOCK_CANBitRateSet_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  uint32 ReturnVal;
  uint32 Expected_ui32Base;
  uint32 Expected_ui32SourceClock;
  uint32 Expected_ui32BitRate;
  char IgnoreArg_ui32Base;
  char IgnoreArg_ui32SourceClock;
  char IgnoreArg_ui32BitRate;

} CMOCK_CANBitRateSet_CALL_INSTANCE;

typedef struct _CMOCK_CANDisable_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  uint32 Expected_ui32Base;
  char IgnoreArg_ui32Base;

} CMOCK_CANDisable_CALL_INSTANCE;

typedef struct _CMOCK_CANEnable_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  uint32 Expected_ui32Base;
  char IgnoreArg_ui32Base;

} CMOCK_CANEnable_CALL_INSTANCE;

typedef struct _CMOCK_CANErrCntrGet_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  boolean ReturnVal;
  uint32 Expected_ui32Base;
  uint32* Expected_pui32RxCount;
  uint32* Expected_pui32TxCount;
  int Expected_pui32RxCount_Depth;
  int Expected_pui32TxCount_Depth;
  char ReturnThruPtr_pui32RxCount_Used;
  uint32 const* ReturnThruPtr_pui32RxCount_Val;
  size_t ReturnThruPtr_pui32RxCount_Size;
  char ReturnThruPtr_pui32TxCount_Used;
  uint32 const* ReturnThruPtr_pui32TxCount_Val;
  size_t ReturnThruPtr_pui32TxCount_Size;
  char IgnoreArg_ui32Base;
  char IgnoreArg_pui32RxCount;
  char IgnoreArg_pui32TxCount;

} CMOCK_CANErrCntrGet_CALL_INSTANCE;

typedef struct _CMOCK_CANInit_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  uint32 Expected_ui32Base;
  char IgnoreArg_ui32Base;

} CMOCK_CANInit_CALL_INSTANCE;

typedef struct _CMOCK_CANIntClear_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  uint32 Expected_ui32Base;
  uint32 Expected_ui32IntClr;
  char IgnoreArg_ui32Base;
  char IgnoreArg_ui32IntClr;

} CMOCK_CANIntClear_CALL_INSTANCE;

typedef struct _CMOCK_CANIntDisable_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  uint32 Expected_ui32Base;
  uint32 Expected_ui32IntFlags;
  char IgnoreArg_ui32Base;
  char IgnoreArg_ui32IntFlags;

} CMOCK_CANIntDisable_CALL_INSTANCE;

typedef struct _CMOCK_CANIntEnable_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  uint32 Expected_ui32Base;
  uint32 Expected_ui32IntFlags;
  char IgnoreArg_ui32Base;
  char IgnoreArg_ui32IntFlags;

} CMOCK_CANIntEnable_CALL_INSTANCE;

typedef struct _CMOCK_CANIntRegister_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  uint32 Expected_ui32Base;
  cmock_can_lib_func_ptr1 Expected_pfnHandler;
  char IgnoreArg_ui32Base;
  char IgnoreArg_pfnHandler;

} CMOCK_CANIntRegister_CALL_INSTANCE;

typedef struct _CMOCK_CANIntStatus_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  uint32 ReturnVal;
  uint32 Expected_ui32Base;
  tCANIntStsReg Expected_eIntStsReg;
  char IgnoreArg_ui32Base;
  char IgnoreArg_eIntStsReg;

} CMOCK_CANIntStatus_CALL_INSTANCE;

typedef struct _CMOCK_CANIntUnregister_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  uint32 Expected_ui32Base;
  char IgnoreArg_ui32Base;

} CMOCK_CANIntUnregister_CALL_INSTANCE;

typedef struct _CMOCK_CANMessageClear_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  uint32 Expected_ui32Base;
  uint32 Expected_ui32ObjID;
  char IgnoreArg_ui32Base;
  char IgnoreArg_ui32ObjID;

} CMOCK_CANMessageClear_CALL_INSTANCE;

typedef struct _CMOCK_CANMessageGet_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  uint32 Expected_ui32Base;
  uint32 Expected_ui32ObjID;
  tCANMsgObject* Expected_psMsgObject;
  boolean Expected_bClrPendingInt;
  int Expected_psMsgObject_Depth;
  char ReturnThruPtr_psMsgObject_Used;
  tCANMsgObject const* ReturnThruPtr_psMsgObject_Val;
  size_t ReturnThruPtr_psMsgObject_Size;
  char IgnoreArg_ui32Base;
  char IgnoreArg_ui32ObjID;
  char IgnoreArg_psMsgObject;
  char IgnoreArg_bClrPendingInt;

} CMOCK_CANMessageGet_CALL_INSTANCE;

typedef struct _CMOCK_CANMessageSet_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  uint32 Expected_ui32Base;
  uint32 Expected_ui32ObjID;
  tCANMsgObject* Expected_psMsgObject;
  tMsgObjType Expected_eMsgType;
  int Expected_psMsgObject_Depth;
  char ReturnThruPtr_psMsgObject_Used;
  tCANMsgObject const* ReturnThruPtr_psMsgObject_Val;
  size_t ReturnThruPtr_psMsgObject_Size;
  char IgnoreArg_ui32Base;
  char IgnoreArg_ui32ObjID;
  char IgnoreArg_psMsgObject;
  char IgnoreArg_eMsgType;

} CMOCK_CANMessageSet_CALL_INSTANCE;

typedef struct _CMOCK_CANRetryGet_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  boolean ReturnVal;
  uint32 Expected_ui32Base;
  char IgnoreArg_ui32Base;

} CMOCK_CANRetryGet_CALL_INSTANCE;

typedef struct _CMOCK_CANRetrySet_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  uint32 Expected_ui32Base;
  boolean Expected_bAutoRetry;
  char IgnoreArg_ui32Base;
  char IgnoreArg_bAutoRetry;

} CMOCK_CANRetrySet_CALL_INSTANCE;

typedef struct _CMOCK_CANStatusGet_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  uint32 ReturnVal;
  uint32 Expected_ui32Base;
  tCANStsReg Expected_eStatusReg;
  char IgnoreArg_ui32Base;
  char IgnoreArg_eStatusReg;

} CMOCK_CANStatusGet_CALL_INSTANCE;

static struct mock_can_libInstance
{
  char CANBitTimingGet_IgnoreBool;
  char CANBitTimingGet_CallbackBool;
  CMOCK_CANBitTimingGet_CALLBACK CANBitTimingGet_CallbackFunctionPointer;
  int CANBitTimingGet_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE CANBitTimingGet_CallInstance;
  char CANBitTimingSet_IgnoreBool;
  char CANBitTimingSet_CallbackBool;
  CMOCK_CANBitTimingSet_CALLBACK CANBitTimingSet_CallbackFunctionPointer;
  int CANBitTimingSet_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE CANBitTimingSet_CallInstance;
  char CANBitRateSet_IgnoreBool;
  uint32 CANBitRateSet_FinalReturn;
  char CANBitRateSet_CallbackBool;
  CMOCK_CANBitRateSet_CALLBACK CANBitRateSet_CallbackFunctionPointer;
  int CANBitRateSet_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE CANBitRateSet_CallInstance;
  char CANDisable_IgnoreBool;
  char CANDisable_CallbackBool;
  CMOCK_CANDisable_CALLBACK CANDisable_CallbackFunctionPointer;
  int CANDisable_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE CANDisable_CallInstance;
  char CANEnable_IgnoreBool;
  char CANEnable_CallbackBool;
  CMOCK_CANEnable_CALLBACK CANEnable_CallbackFunctionPointer;
  int CANEnable_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE CANEnable_CallInstance;
  char CANErrCntrGet_IgnoreBool;
  boolean CANErrCntrGet_FinalReturn;
  char CANErrCntrGet_CallbackBool;
  CMOCK_CANErrCntrGet_CALLBACK CANErrCntrGet_CallbackFunctionPointer;
  int CANErrCntrGet_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE CANErrCntrGet_CallInstance;
  char CANInit_IgnoreBool;
  char CANInit_CallbackBool;
  CMOCK_CANInit_CALLBACK CANInit_CallbackFunctionPointer;
  int CANInit_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE CANInit_CallInstance;
  char CANIntClear_IgnoreBool;
  char CANIntClear_CallbackBool;
  CMOCK_CANIntClear_CALLBACK CANIntClear_CallbackFunctionPointer;
  int CANIntClear_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE CANIntClear_CallInstance;
  char CANIntDisable_IgnoreBool;
  char CANIntDisable_CallbackBool;
  CMOCK_CANIntDisable_CALLBACK CANIntDisable_CallbackFunctionPointer;
  int CANIntDisable_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE CANIntDisable_CallInstance;
  char CANIntEnable_IgnoreBool;
  char CANIntEnable_CallbackBool;
  CMOCK_CANIntEnable_CALLBACK CANIntEnable_CallbackFunctionPointer;
  int CANIntEnable_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE CANIntEnable_CallInstance;
  char CANIntRegister_IgnoreBool;
  char CANIntRegister_CallbackBool;
  CMOCK_CANIntRegister_CALLBACK CANIntRegister_CallbackFunctionPointer;
  int CANIntRegister_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE CANIntRegister_CallInstance;
  char CANIntStatus_IgnoreBool;
  uint32 CANIntStatus_FinalReturn;
  char CANIntStatus_CallbackBool;
  CMOCK_CANIntStatus_CALLBACK CANIntStatus_CallbackFunctionPointer;
  int CANIntStatus_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE CANIntStatus_CallInstance;
  char CANIntUnregister_IgnoreBool;
  char CANIntUnregister_CallbackBool;
  CMOCK_CANIntUnregister_CALLBACK CANIntUnregister_CallbackFunctionPointer;
  int CANIntUnregister_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE CANIntUnregister_CallInstance;
  char CANMessageClear_IgnoreBool;
  char CANMessageClear_CallbackBool;
  CMOCK_CANMessageClear_CALLBACK CANMessageClear_CallbackFunctionPointer;
  int CANMessageClear_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE CANMessageClear_CallInstance;
  char CANMessageGet_IgnoreBool;
  char CANMessageGet_CallbackBool;
  CMOCK_CANMessageGet_CALLBACK CANMessageGet_CallbackFunctionPointer;
  int CANMessageGet_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE CANMessageGet_CallInstance;
  char CANMessageSet_IgnoreBool;
  char CANMessageSet_CallbackBool;
  CMOCK_CANMessageSet_CALLBACK CANMessageSet_CallbackFunctionPointer;
  int CANMessageSet_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE CANMessageSet_CallInstance;
  char CANRetryGet_IgnoreBool;
  boolean CANRetryGet_FinalReturn;
  char CANRetryGet_CallbackBool;
  CMOCK_CANRetryGet_CALLBACK CANRetryGet_CallbackFunctionPointer;
  int CANRetryGet_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE CANRetryGet_CallInstance;
  char CANRetrySet_IgnoreBool;
  char CANRetrySet_CallbackBool;
  CMOCK_CANRetrySet_CALLBACK CANRetrySet_CallbackFunctionPointer;
  int CANRetrySet_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE CANRetrySet_CallInstance;
  char CANStatusGet_IgnoreBool;
  uint32 CANStatusGet_FinalReturn;
  char CANStatusGet_CallbackBool;
  CMOCK_CANStatusGet_CALLBACK CANStatusGet_CallbackFunctionPointer;
  int CANStatusGet_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE CANStatusGet_CallInstance;
} Mock;

extern jmp_buf AbortFrame;

void mock_can_lib_Verify(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_MEM_INDEX_TYPE call_instance;
  call_instance = Mock.CANBitTimingGet_CallInstance;
  if (Mock.CANBitTimingGet_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_CANBitTimingGet);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.CANBitTimingGet_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.CANBitTimingSet_CallInstance;
  if (Mock.CANBitTimingSet_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_CANBitTimingSet);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.CANBitTimingSet_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.CANBitRateSet_CallInstance;
  if (Mock.CANBitRateSet_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_CANBitRateSet);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.CANBitRateSet_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.CANDisable_CallInstance;
  if (Mock.CANDisable_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_CANDisable);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.CANDisable_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.CANEnable_CallInstance;
  if (Mock.CANEnable_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_CANEnable);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.CANEnable_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.CANErrCntrGet_CallInstance;
  if (Mock.CANErrCntrGet_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_CANErrCntrGet);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.CANErrCntrGet_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.CANInit_CallInstance;
  if (Mock.CANInit_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_CANInit);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.CANInit_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.CANIntClear_CallInstance;
  if (Mock.CANIntClear_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_CANIntClear);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.CANIntClear_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.CANIntDisable_CallInstance;
  if (Mock.CANIntDisable_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_CANIntDisable);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.CANIntDisable_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.CANIntEnable_CallInstance;
  if (Mock.CANIntEnable_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_CANIntEnable);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.CANIntEnable_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.CANIntRegister_CallInstance;
  if (Mock.CANIntRegister_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_CANIntRegister);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.CANIntRegister_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.CANIntStatus_CallInstance;
  if (Mock.CANIntStatus_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_CANIntStatus);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.CANIntStatus_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.CANIntUnregister_CallInstance;
  if (Mock.CANIntUnregister_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_CANIntUnregister);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.CANIntUnregister_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.CANMessageClear_CallInstance;
  if (Mock.CANMessageClear_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_CANMessageClear);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.CANMessageClear_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.CANMessageGet_CallInstance;
  if (Mock.CANMessageGet_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_CANMessageGet);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.CANMessageGet_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.CANMessageSet_CallInstance;
  if (Mock.CANMessageSet_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_CANMessageSet);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.CANMessageSet_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.CANRetryGet_CallInstance;
  if (Mock.CANRetryGet_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_CANRetryGet);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.CANRetryGet_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.CANRetrySet_CallInstance;
  if (Mock.CANRetrySet_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_CANRetrySet);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.CANRetrySet_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.CANStatusGet_CallInstance;
  if (Mock.CANStatusGet_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_CANStatusGet);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.CANStatusGet_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
}

void mock_can_lib_Init(void)
{
  mock_can_lib_Destroy();
}

void mock_can_lib_Destroy(void)
{
  CMock_Guts_MemFreeAll();
  memset(&Mock, 0, sizeof(Mock));
}

void CANBitTimingGet(uint32 ui32Base, tCANBitClkParms* psClkParms)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_CANBitTimingGet_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_CANBitTimingGet);
  cmock_call_instance = (CMOCK_CANBitTimingGet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.CANBitTimingGet_CallInstance);
  Mock.CANBitTimingGet_CallInstance = CMock_Guts_MemNext(Mock.CANBitTimingGet_CallInstance);
  if (Mock.CANBitTimingGet_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.CANBitTimingGet_CallbackBool &&
      Mock.CANBitTimingGet_CallbackFunctionPointer != NULL)
  {
    Mock.CANBitTimingGet_CallbackFunctionPointer(ui32Base, psClkParms, Mock.CANBitTimingGet_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_ui32Base)
  {
    UNITY_SET_DETAILS(CMockString_CANBitTimingGet,CMockString_ui32Base);
    UNITY_TEST_ASSERT_EQUAL_UINT32(cmock_call_instance->Expected_ui32Base, ui32Base, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_psClkParms)
  {
    UNITY_SET_DETAILS(CMockString_CANBitTimingGet,CMockString_psClkParms);
    if (cmock_call_instance->Expected_psClkParms == NULL)
      { UNITY_TEST_ASSERT_NULL(psClkParms, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_psClkParms), (void*)(psClkParms), sizeof(tCANBitClkParms), cmock_call_instance->Expected_psClkParms_Depth, cmock_line, CMockStringMismatch); }
  }
  }
  if (Mock.CANBitTimingGet_CallbackFunctionPointer != NULL)
  {
    Mock.CANBitTimingGet_CallbackFunctionPointer(ui32Base, psClkParms, Mock.CANBitTimingGet_CallbackCalls++);
  }
  if (cmock_call_instance->ReturnThruPtr_psClkParms_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(psClkParms, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)psClkParms, (const void*)cmock_call_instance->ReturnThruPtr_psClkParms_Val,
      cmock_call_instance->ReturnThruPtr_psClkParms_Size);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_CANBitTimingGet(CMOCK_CANBitTimingGet_CALL_INSTANCE* cmock_call_instance, uint32 ui32Base, tCANBitClkParms* psClkParms, int psClkParms_Depth);
void CMockExpectParameters_CANBitTimingGet(CMOCK_CANBitTimingGet_CALL_INSTANCE* cmock_call_instance, uint32 ui32Base, tCANBitClkParms* psClkParms, int psClkParms_Depth)
{
  cmock_call_instance->Expected_ui32Base = ui32Base;
  cmock_call_instance->IgnoreArg_ui32Base = 0;
  cmock_call_instance->Expected_psClkParms = psClkParms;
  cmock_call_instance->Expected_psClkParms_Depth = psClkParms_Depth;
  cmock_call_instance->IgnoreArg_psClkParms = 0;
  cmock_call_instance->ReturnThruPtr_psClkParms_Used = 0;
}

void CANBitTimingGet_CMockIgnore(void)
{
  Mock.CANBitTimingGet_IgnoreBool = (char)1;
}

void CANBitTimingGet_CMockStopIgnore(void)
{
  Mock.CANBitTimingGet_IgnoreBool = (char)0;
}

void CANBitTimingGet_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_CANBitTimingGet_CALL_INSTANCE));
  CMOCK_CANBitTimingGet_CALL_INSTANCE* cmock_call_instance = (CMOCK_CANBitTimingGet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.CANBitTimingGet_CallInstance = CMock_Guts_MemChain(Mock.CANBitTimingGet_CallInstance, cmock_guts_index);
  Mock.CANBitTimingGet_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void CANBitTimingGet_CMockExpect(UNITY_LINE_TYPE cmock_line, uint32 ui32Base, tCANBitClkParms* psClkParms)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_CANBitTimingGet_CALL_INSTANCE));
  CMOCK_CANBitTimingGet_CALL_INSTANCE* cmock_call_instance = (CMOCK_CANBitTimingGet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.CANBitTimingGet_CallInstance = CMock_Guts_MemChain(Mock.CANBitTimingGet_CallInstance, cmock_guts_index);
  Mock.CANBitTimingGet_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_CANBitTimingGet(cmock_call_instance, ui32Base, psClkParms, 1);
}

void CANBitTimingGet_AddCallback(CMOCK_CANBitTimingGet_CALLBACK Callback)
{
  Mock.CANBitTimingGet_IgnoreBool = (char)0;
  Mock.CANBitTimingGet_CallbackBool = (char)1;
  Mock.CANBitTimingGet_CallbackFunctionPointer = Callback;
}

void CANBitTimingGet_Stub(CMOCK_CANBitTimingGet_CALLBACK Callback)
{
  Mock.CANBitTimingGet_IgnoreBool = (char)0;
  Mock.CANBitTimingGet_CallbackBool = (char)0;
  Mock.CANBitTimingGet_CallbackFunctionPointer = Callback;
}

void CANBitTimingGet_CMockExpectWithArray(UNITY_LINE_TYPE cmock_line, uint32 ui32Base, tCANBitClkParms* psClkParms, int psClkParms_Depth)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_CANBitTimingGet_CALL_INSTANCE));
  CMOCK_CANBitTimingGet_CALL_INSTANCE* cmock_call_instance = (CMOCK_CANBitTimingGet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.CANBitTimingGet_CallInstance = CMock_Guts_MemChain(Mock.CANBitTimingGet_CallInstance, cmock_guts_index);
  Mock.CANBitTimingGet_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_CANBitTimingGet(cmock_call_instance, ui32Base, psClkParms, psClkParms_Depth);
}

void CANBitTimingGet_CMockReturnMemThruPtr_psClkParms(UNITY_LINE_TYPE cmock_line, tCANBitClkParms const* psClkParms, size_t cmock_size)
{
  CMOCK_CANBitTimingGet_CALL_INSTANCE* cmock_call_instance = (CMOCK_CANBitTimingGet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.CANBitTimingGet_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_psClkParms_Used = 1;
  cmock_call_instance->ReturnThruPtr_psClkParms_Val = psClkParms;
  cmock_call_instance->ReturnThruPtr_psClkParms_Size = cmock_size;
}

void CANBitTimingGet_CMockIgnoreArg_ui32Base(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_CANBitTimingGet_CALL_INSTANCE* cmock_call_instance = (CMOCK_CANBitTimingGet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.CANBitTimingGet_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_ui32Base = 1;
}

void CANBitTimingGet_CMockIgnoreArg_psClkParms(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_CANBitTimingGet_CALL_INSTANCE* cmock_call_instance = (CMOCK_CANBitTimingGet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.CANBitTimingGet_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_psClkParms = 1;
}

void CANBitTimingSet(uint32 ui32Base, tCANBitClkParms* psClkParms)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_CANBitTimingSet_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_CANBitTimingSet);
  cmock_call_instance = (CMOCK_CANBitTimingSet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.CANBitTimingSet_CallInstance);
  Mock.CANBitTimingSet_CallInstance = CMock_Guts_MemNext(Mock.CANBitTimingSet_CallInstance);
  if (Mock.CANBitTimingSet_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.CANBitTimingSet_CallbackBool &&
      Mock.CANBitTimingSet_CallbackFunctionPointer != NULL)
  {
    Mock.CANBitTimingSet_CallbackFunctionPointer(ui32Base, psClkParms, Mock.CANBitTimingSet_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_ui32Base)
  {
    UNITY_SET_DETAILS(CMockString_CANBitTimingSet,CMockString_ui32Base);
    UNITY_TEST_ASSERT_EQUAL_UINT32(cmock_call_instance->Expected_ui32Base, ui32Base, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_psClkParms)
  {
    UNITY_SET_DETAILS(CMockString_CANBitTimingSet,CMockString_psClkParms);
    if (cmock_call_instance->Expected_psClkParms == NULL)
      { UNITY_TEST_ASSERT_NULL(psClkParms, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_psClkParms), (void*)(psClkParms), sizeof(tCANBitClkParms), cmock_call_instance->Expected_psClkParms_Depth, cmock_line, CMockStringMismatch); }
  }
  }
  if (Mock.CANBitTimingSet_CallbackFunctionPointer != NULL)
  {
    Mock.CANBitTimingSet_CallbackFunctionPointer(ui32Base, psClkParms, Mock.CANBitTimingSet_CallbackCalls++);
  }
  if (cmock_call_instance->ReturnThruPtr_psClkParms_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(psClkParms, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)psClkParms, (const void*)cmock_call_instance->ReturnThruPtr_psClkParms_Val,
      cmock_call_instance->ReturnThruPtr_psClkParms_Size);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_CANBitTimingSet(CMOCK_CANBitTimingSet_CALL_INSTANCE* cmock_call_instance, uint32 ui32Base, tCANBitClkParms* psClkParms, int psClkParms_Depth);
void CMockExpectParameters_CANBitTimingSet(CMOCK_CANBitTimingSet_CALL_INSTANCE* cmock_call_instance, uint32 ui32Base, tCANBitClkParms* psClkParms, int psClkParms_Depth)
{
  cmock_call_instance->Expected_ui32Base = ui32Base;
  cmock_call_instance->IgnoreArg_ui32Base = 0;
  cmock_call_instance->Expected_psClkParms = psClkParms;
  cmock_call_instance->Expected_psClkParms_Depth = psClkParms_Depth;
  cmock_call_instance->IgnoreArg_psClkParms = 0;
  cmock_call_instance->ReturnThruPtr_psClkParms_Used = 0;
}

void CANBitTimingSet_CMockIgnore(void)
{
  Mock.CANBitTimingSet_IgnoreBool = (char)1;
}

void CANBitTimingSet_CMockStopIgnore(void)
{
  Mock.CANBitTimingSet_IgnoreBool = (char)0;
}

void CANBitTimingSet_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_CANBitTimingSet_CALL_INSTANCE));
  CMOCK_CANBitTimingSet_CALL_INSTANCE* cmock_call_instance = (CMOCK_CANBitTimingSet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.CANBitTimingSet_CallInstance = CMock_Guts_MemChain(Mock.CANBitTimingSet_CallInstance, cmock_guts_index);
  Mock.CANBitTimingSet_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void CANBitTimingSet_CMockExpect(UNITY_LINE_TYPE cmock_line, uint32 ui32Base, tCANBitClkParms* psClkParms)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_CANBitTimingSet_CALL_INSTANCE));
  CMOCK_CANBitTimingSet_CALL_INSTANCE* cmock_call_instance = (CMOCK_CANBitTimingSet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.CANBitTimingSet_CallInstance = CMock_Guts_MemChain(Mock.CANBitTimingSet_CallInstance, cmock_guts_index);
  Mock.CANBitTimingSet_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_CANBitTimingSet(cmock_call_instance, ui32Base, psClkParms, 1);
}

void CANBitTimingSet_AddCallback(CMOCK_CANBitTimingSet_CALLBACK Callback)
{
  Mock.CANBitTimingSet_IgnoreBool = (char)0;
  Mock.CANBitTimingSet_CallbackBool = (char)1;
  Mock.CANBitTimingSet_CallbackFunctionPointer = Callback;
}

void CANBitTimingSet_Stub(CMOCK_CANBitTimingSet_CALLBACK Callback)
{
  Mock.CANBitTimingSet_IgnoreBool = (char)0;
  Mock.CANBitTimingSet_CallbackBool = (char)0;
  Mock.CANBitTimingSet_CallbackFunctionPointer = Callback;
}

void CANBitTimingSet_CMockExpectWithArray(UNITY_LINE_TYPE cmock_line, uint32 ui32Base, tCANBitClkParms* psClkParms, int psClkParms_Depth)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_CANBitTimingSet_CALL_INSTANCE));
  CMOCK_CANBitTimingSet_CALL_INSTANCE* cmock_call_instance = (CMOCK_CANBitTimingSet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.CANBitTimingSet_CallInstance = CMock_Guts_MemChain(Mock.CANBitTimingSet_CallInstance, cmock_guts_index);
  Mock.CANBitTimingSet_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_CANBitTimingSet(cmock_call_instance, ui32Base, psClkParms, psClkParms_Depth);
}

void CANBitTimingSet_CMockReturnMemThruPtr_psClkParms(UNITY_LINE_TYPE cmock_line, tCANBitClkParms const* psClkParms, size_t cmock_size)
{
  CMOCK_CANBitTimingSet_CALL_INSTANCE* cmock_call_instance = (CMOCK_CANBitTimingSet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.CANBitTimingSet_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_psClkParms_Used = 1;
  cmock_call_instance->ReturnThruPtr_psClkParms_Val = psClkParms;
  cmock_call_instance->ReturnThruPtr_psClkParms_Size = cmock_size;
}

void CANBitTimingSet_CMockIgnoreArg_ui32Base(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_CANBitTimingSet_CALL_INSTANCE* cmock_call_instance = (CMOCK_CANBitTimingSet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.CANBitTimingSet_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_ui32Base = 1;
}

void CANBitTimingSet_CMockIgnoreArg_psClkParms(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_CANBitTimingSet_CALL_INSTANCE* cmock_call_instance = (CMOCK_CANBitTimingSet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.CANBitTimingSet_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_psClkParms = 1;
}

uint32 CANBitRateSet(uint32 ui32Base, uint32 ui32SourceClock, uint32 ui32BitRate)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_CANBitRateSet_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_CANBitRateSet);
  cmock_call_instance = (CMOCK_CANBitRateSet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.CANBitRateSet_CallInstance);
  Mock.CANBitRateSet_CallInstance = CMock_Guts_MemNext(Mock.CANBitRateSet_CallInstance);
  if (Mock.CANBitRateSet_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.CANBitRateSet_FinalReturn;
    Mock.CANBitRateSet_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.CANBitRateSet_CallbackBool &&
      Mock.CANBitRateSet_CallbackFunctionPointer != NULL)
  {
    uint32 cmock_cb_ret = Mock.CANBitRateSet_CallbackFunctionPointer(ui32Base, ui32SourceClock, ui32BitRate, Mock.CANBitRateSet_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_ui32Base)
  {
    UNITY_SET_DETAILS(CMockString_CANBitRateSet,CMockString_ui32Base);
    UNITY_TEST_ASSERT_EQUAL_UINT32(cmock_call_instance->Expected_ui32Base, ui32Base, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_ui32SourceClock)
  {
    UNITY_SET_DETAILS(CMockString_CANBitRateSet,CMockString_ui32SourceClock);
    UNITY_TEST_ASSERT_EQUAL_UINT32(cmock_call_instance->Expected_ui32SourceClock, ui32SourceClock, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_ui32BitRate)
  {
    UNITY_SET_DETAILS(CMockString_CANBitRateSet,CMockString_ui32BitRate);
    UNITY_TEST_ASSERT_EQUAL_UINT32(cmock_call_instance->Expected_ui32BitRate, ui32BitRate, cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.CANBitRateSet_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.CANBitRateSet_CallbackFunctionPointer(ui32Base, ui32SourceClock, ui32BitRate, Mock.CANBitRateSet_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_CANBitRateSet(CMOCK_CANBitRateSet_CALL_INSTANCE* cmock_call_instance, uint32 ui32Base, uint32 ui32SourceClock, uint32 ui32BitRate);
void CMockExpectParameters_CANBitRateSet(CMOCK_CANBitRateSet_CALL_INSTANCE* cmock_call_instance, uint32 ui32Base, uint32 ui32SourceClock, uint32 ui32BitRate)
{
  cmock_call_instance->Expected_ui32Base = ui32Base;
  cmock_call_instance->IgnoreArg_ui32Base = 0;
  cmock_call_instance->Expected_ui32SourceClock = ui32SourceClock;
  cmock_call_instance->IgnoreArg_ui32SourceClock = 0;
  cmock_call_instance->Expected_ui32BitRate = ui32BitRate;
  cmock_call_instance->IgnoreArg_ui32BitRate = 0;
}

void CANBitRateSet_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32 cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_CANBitRateSet_CALL_INSTANCE));
  CMOCK_CANBitRateSet_CALL_INSTANCE* cmock_call_instance = (CMOCK_CANBitRateSet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.CANBitRateSet_CallInstance = CMock_Guts_MemChain(Mock.CANBitRateSet_CallInstance, cmock_guts_index);
  Mock.CANBitRateSet_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.CANBitRateSet_IgnoreBool = (char)1;
}

void CANBitRateSet_CMockStopIgnore(void)
{
  if(Mock.CANBitRateSet_IgnoreBool)
    Mock.CANBitRateSet_CallInstance = CMock_Guts_MemNext(Mock.CANBitRateSet_CallInstance);
  Mock.CANBitRateSet_IgnoreBool = (char)0;
}

void CANBitRateSet_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, uint32 cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_CANBitRateSet_CALL_INSTANCE));
  CMOCK_CANBitRateSet_CALL_INSTANCE* cmock_call_instance = (CMOCK_CANBitRateSet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.CANBitRateSet_CallInstance = CMock_Guts_MemChain(Mock.CANBitRateSet_CallInstance, cmock_guts_index);
  Mock.CANBitRateSet_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void CANBitRateSet_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32 ui32Base, uint32 ui32SourceClock, uint32 ui32BitRate, uint32 cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_CANBitRateSet_CALL_INSTANCE));
  CMOCK_CANBitRateSet_CALL_INSTANCE* cmock_call_instance = (CMOCK_CANBitRateSet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.CANBitRateSet_CallInstance = CMock_Guts_MemChain(Mock.CANBitRateSet_CallInstance, cmock_guts_index);
  Mock.CANBitRateSet_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_CANBitRateSet(cmock_call_instance, ui32Base, ui32SourceClock, ui32BitRate);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void CANBitRateSet_AddCallback(CMOCK_CANBitRateSet_CALLBACK Callback)
{
  Mock.CANBitRateSet_IgnoreBool = (char)0;
  Mock.CANBitRateSet_CallbackBool = (char)1;
  Mock.CANBitRateSet_CallbackFunctionPointer = Callback;
}

void CANBitRateSet_Stub(CMOCK_CANBitRateSet_CALLBACK Callback)
{
  Mock.CANBitRateSet_IgnoreBool = (char)0;
  Mock.CANBitRateSet_CallbackBool = (char)0;
  Mock.CANBitRateSet_CallbackFunctionPointer = Callback;
}

void CANBitRateSet_CMockIgnoreArg_ui32Base(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_CANBitRateSet_CALL_INSTANCE* cmock_call_instance = (CMOCK_CANBitRateSet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.CANBitRateSet_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_ui32Base = 1;
}

void CANBitRateSet_CMockIgnoreArg_ui32SourceClock(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_CANBitRateSet_CALL_INSTANCE* cmock_call_instance = (CMOCK_CANBitRateSet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.CANBitRateSet_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_ui32SourceClock = 1;
}

void CANBitRateSet_CMockIgnoreArg_ui32BitRate(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_CANBitRateSet_CALL_INSTANCE* cmock_call_instance = (CMOCK_CANBitRateSet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.CANBitRateSet_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_ui32BitRate = 1;
}

void CANDisable(uint32 ui32Base)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_CANDisable_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_CANDisable);
  cmock_call_instance = (CMOCK_CANDisable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.CANDisable_CallInstance);
  Mock.CANDisable_CallInstance = CMock_Guts_MemNext(Mock.CANDisable_CallInstance);
  if (Mock.CANDisable_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.CANDisable_CallbackBool &&
      Mock.CANDisable_CallbackFunctionPointer != NULL)
  {
    Mock.CANDisable_CallbackFunctionPointer(ui32Base, Mock.CANDisable_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_ui32Base)
  {
    UNITY_SET_DETAILS(CMockString_CANDisable,CMockString_ui32Base);
    UNITY_TEST_ASSERT_EQUAL_UINT32(cmock_call_instance->Expected_ui32Base, ui32Base, cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.CANDisable_CallbackFunctionPointer != NULL)
  {
    Mock.CANDisable_CallbackFunctionPointer(ui32Base, Mock.CANDisable_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_CANDisable(CMOCK_CANDisable_CALL_INSTANCE* cmock_call_instance, uint32 ui32Base);
void CMockExpectParameters_CANDisable(CMOCK_CANDisable_CALL_INSTANCE* cmock_call_instance, uint32 ui32Base)
{
  cmock_call_instance->Expected_ui32Base = ui32Base;
  cmock_call_instance->IgnoreArg_ui32Base = 0;
}

void CANDisable_CMockIgnore(void)
{
  Mock.CANDisable_IgnoreBool = (char)1;
}

void CANDisable_CMockStopIgnore(void)
{
  Mock.CANDisable_IgnoreBool = (char)0;
}

void CANDisable_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_CANDisable_CALL_INSTANCE));
  CMOCK_CANDisable_CALL_INSTANCE* cmock_call_instance = (CMOCK_CANDisable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.CANDisable_CallInstance = CMock_Guts_MemChain(Mock.CANDisable_CallInstance, cmock_guts_index);
  Mock.CANDisable_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void CANDisable_CMockExpect(UNITY_LINE_TYPE cmock_line, uint32 ui32Base)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_CANDisable_CALL_INSTANCE));
  CMOCK_CANDisable_CALL_INSTANCE* cmock_call_instance = (CMOCK_CANDisable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.CANDisable_CallInstance = CMock_Guts_MemChain(Mock.CANDisable_CallInstance, cmock_guts_index);
  Mock.CANDisable_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_CANDisable(cmock_call_instance, ui32Base);
}

void CANDisable_AddCallback(CMOCK_CANDisable_CALLBACK Callback)
{
  Mock.CANDisable_IgnoreBool = (char)0;
  Mock.CANDisable_CallbackBool = (char)1;
  Mock.CANDisable_CallbackFunctionPointer = Callback;
}

void CANDisable_Stub(CMOCK_CANDisable_CALLBACK Callback)
{
  Mock.CANDisable_IgnoreBool = (char)0;
  Mock.CANDisable_CallbackBool = (char)0;
  Mock.CANDisable_CallbackFunctionPointer = Callback;
}

void CANDisable_CMockIgnoreArg_ui32Base(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_CANDisable_CALL_INSTANCE* cmock_call_instance = (CMOCK_CANDisable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.CANDisable_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_ui32Base = 1;
}

void CANEnable(uint32 ui32Base)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_CANEnable_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_CANEnable);
  cmock_call_instance = (CMOCK_CANEnable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.CANEnable_CallInstance);
  Mock.CANEnable_CallInstance = CMock_Guts_MemNext(Mock.CANEnable_CallInstance);
  if (Mock.CANEnable_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.CANEnable_CallbackBool &&
      Mock.CANEnable_CallbackFunctionPointer != NULL)
  {
    Mock.CANEnable_CallbackFunctionPointer(ui32Base, Mock.CANEnable_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_ui32Base)
  {
    UNITY_SET_DETAILS(CMockString_CANEnable,CMockString_ui32Base);
    UNITY_TEST_ASSERT_EQUAL_UINT32(cmock_call_instance->Expected_ui32Base, ui32Base, cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.CANEnable_CallbackFunctionPointer != NULL)
  {
    Mock.CANEnable_CallbackFunctionPointer(ui32Base, Mock.CANEnable_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_CANEnable(CMOCK_CANEnable_CALL_INSTANCE* cmock_call_instance, uint32 ui32Base);
void CMockExpectParameters_CANEnable(CMOCK_CANEnable_CALL_INSTANCE* cmock_call_instance, uint32 ui32Base)
{
  cmock_call_instance->Expected_ui32Base = ui32Base;
  cmock_call_instance->IgnoreArg_ui32Base = 0;
}

void CANEnable_CMockIgnore(void)
{
  Mock.CANEnable_IgnoreBool = (char)1;
}

void CANEnable_CMockStopIgnore(void)
{
  Mock.CANEnable_IgnoreBool = (char)0;
}

void CANEnable_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_CANEnable_CALL_INSTANCE));
  CMOCK_CANEnable_CALL_INSTANCE* cmock_call_instance = (CMOCK_CANEnable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.CANEnable_CallInstance = CMock_Guts_MemChain(Mock.CANEnable_CallInstance, cmock_guts_index);
  Mock.CANEnable_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void CANEnable_CMockExpect(UNITY_LINE_TYPE cmock_line, uint32 ui32Base)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_CANEnable_CALL_INSTANCE));
  CMOCK_CANEnable_CALL_INSTANCE* cmock_call_instance = (CMOCK_CANEnable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.CANEnable_CallInstance = CMock_Guts_MemChain(Mock.CANEnable_CallInstance, cmock_guts_index);
  Mock.CANEnable_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_CANEnable(cmock_call_instance, ui32Base);
}

void CANEnable_AddCallback(CMOCK_CANEnable_CALLBACK Callback)
{
  Mock.CANEnable_IgnoreBool = (char)0;
  Mock.CANEnable_CallbackBool = (char)1;
  Mock.CANEnable_CallbackFunctionPointer = Callback;
}

void CANEnable_Stub(CMOCK_CANEnable_CALLBACK Callback)
{
  Mock.CANEnable_IgnoreBool = (char)0;
  Mock.CANEnable_CallbackBool = (char)0;
  Mock.CANEnable_CallbackFunctionPointer = Callback;
}

void CANEnable_CMockIgnoreArg_ui32Base(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_CANEnable_CALL_INSTANCE* cmock_call_instance = (CMOCK_CANEnable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.CANEnable_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_ui32Base = 1;
}

boolean CANErrCntrGet(uint32 ui32Base, uint32* pui32RxCount, uint32* pui32TxCount)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_CANErrCntrGet_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_CANErrCntrGet);
  cmock_call_instance = (CMOCK_CANErrCntrGet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.CANErrCntrGet_CallInstance);
  Mock.CANErrCntrGet_CallInstance = CMock_Guts_MemNext(Mock.CANErrCntrGet_CallInstance);
  if (Mock.CANErrCntrGet_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.CANErrCntrGet_FinalReturn;
    memcpy((void*)(&Mock.CANErrCntrGet_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(boolean[sizeof(cmock_call_instance->ReturnVal) == sizeof(boolean) ? 1 : -1])); /* add boolean to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.CANErrCntrGet_CallbackBool &&
      Mock.CANErrCntrGet_CallbackFunctionPointer != NULL)
  {
    boolean cmock_cb_ret = Mock.CANErrCntrGet_CallbackFunctionPointer(ui32Base, pui32RxCount, pui32TxCount, Mock.CANErrCntrGet_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_ui32Base)
  {
    UNITY_SET_DETAILS(CMockString_CANErrCntrGet,CMockString_ui32Base);
    UNITY_TEST_ASSERT_EQUAL_UINT32(cmock_call_instance->Expected_ui32Base, ui32Base, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_pui32RxCount)
  {
    UNITY_SET_DETAILS(CMockString_CANErrCntrGet,CMockString_pui32RxCount);
    if (cmock_call_instance->Expected_pui32RxCount == NULL)
      { UNITY_TEST_ASSERT_NULL(pui32RxCount, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_UINT32_ARRAY(cmock_call_instance->Expected_pui32RxCount, pui32RxCount, cmock_call_instance->Expected_pui32RxCount_Depth, cmock_line, CMockStringMismatch); }
  }
  if (!cmock_call_instance->IgnoreArg_pui32TxCount)
  {
    UNITY_SET_DETAILS(CMockString_CANErrCntrGet,CMockString_pui32TxCount);
    if (cmock_call_instance->Expected_pui32TxCount == NULL)
      { UNITY_TEST_ASSERT_NULL(pui32TxCount, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_UINT32_ARRAY(cmock_call_instance->Expected_pui32TxCount, pui32TxCount, cmock_call_instance->Expected_pui32TxCount_Depth, cmock_line, CMockStringMismatch); }
  }
  }
  if (Mock.CANErrCntrGet_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.CANErrCntrGet_CallbackFunctionPointer(ui32Base, pui32RxCount, pui32TxCount, Mock.CANErrCntrGet_CallbackCalls++);
  }
  if (cmock_call_instance->ReturnThruPtr_pui32RxCount_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(pui32RxCount, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)pui32RxCount, (const void*)cmock_call_instance->ReturnThruPtr_pui32RxCount_Val,
      cmock_call_instance->ReturnThruPtr_pui32RxCount_Size);
  }
  if (cmock_call_instance->ReturnThruPtr_pui32TxCount_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(pui32TxCount, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)pui32TxCount, (const void*)cmock_call_instance->ReturnThruPtr_pui32TxCount_Val,
      cmock_call_instance->ReturnThruPtr_pui32TxCount_Size);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_CANErrCntrGet(CMOCK_CANErrCntrGet_CALL_INSTANCE* cmock_call_instance, uint32 ui32Base, uint32* pui32RxCount, int pui32RxCount_Depth, uint32* pui32TxCount, int pui32TxCount_Depth);
void CMockExpectParameters_CANErrCntrGet(CMOCK_CANErrCntrGet_CALL_INSTANCE* cmock_call_instance, uint32 ui32Base, uint32* pui32RxCount, int pui32RxCount_Depth, uint32* pui32TxCount, int pui32TxCount_Depth)
{
  cmock_call_instance->Expected_ui32Base = ui32Base;
  cmock_call_instance->IgnoreArg_ui32Base = 0;
  cmock_call_instance->Expected_pui32RxCount = pui32RxCount;
  cmock_call_instance->Expected_pui32RxCount_Depth = pui32RxCount_Depth;
  cmock_call_instance->IgnoreArg_pui32RxCount = 0;
  cmock_call_instance->ReturnThruPtr_pui32RxCount_Used = 0;
  cmock_call_instance->Expected_pui32TxCount = pui32TxCount;
  cmock_call_instance->Expected_pui32TxCount_Depth = pui32TxCount_Depth;
  cmock_call_instance->IgnoreArg_pui32TxCount = 0;
  cmock_call_instance->ReturnThruPtr_pui32TxCount_Used = 0;
}

void CANErrCntrGet_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, boolean cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_CANErrCntrGet_CALL_INSTANCE));
  CMOCK_CANErrCntrGet_CALL_INSTANCE* cmock_call_instance = (CMOCK_CANErrCntrGet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.CANErrCntrGet_CallInstance = CMock_Guts_MemChain(Mock.CANErrCntrGet_CallInstance, cmock_guts_index);
  Mock.CANErrCntrGet_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.CANErrCntrGet_IgnoreBool = (char)1;
}

void CANErrCntrGet_CMockStopIgnore(void)
{
  if(Mock.CANErrCntrGet_IgnoreBool)
    Mock.CANErrCntrGet_CallInstance = CMock_Guts_MemNext(Mock.CANErrCntrGet_CallInstance);
  Mock.CANErrCntrGet_IgnoreBool = (char)0;
}

void CANErrCntrGet_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, boolean cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_CANErrCntrGet_CALL_INSTANCE));
  CMOCK_CANErrCntrGet_CALL_INSTANCE* cmock_call_instance = (CMOCK_CANErrCntrGet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.CANErrCntrGet_CallInstance = CMock_Guts_MemChain(Mock.CANErrCntrGet_CallInstance, cmock_guts_index);
  Mock.CANErrCntrGet_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void CANErrCntrGet_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32 ui32Base, uint32* pui32RxCount, uint32* pui32TxCount, boolean cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_CANErrCntrGet_CALL_INSTANCE));
  CMOCK_CANErrCntrGet_CALL_INSTANCE* cmock_call_instance = (CMOCK_CANErrCntrGet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.CANErrCntrGet_CallInstance = CMock_Guts_MemChain(Mock.CANErrCntrGet_CallInstance, cmock_guts_index);
  Mock.CANErrCntrGet_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_CANErrCntrGet(cmock_call_instance, ui32Base, pui32RxCount, 1, pui32TxCount, 1);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(boolean[sizeof(cmock_to_return) == sizeof(boolean) ? 1 : -1])); /* add boolean to :treat_as_array if this causes an error */
}

void CANErrCntrGet_AddCallback(CMOCK_CANErrCntrGet_CALLBACK Callback)
{
  Mock.CANErrCntrGet_IgnoreBool = (char)0;
  Mock.CANErrCntrGet_CallbackBool = (char)1;
  Mock.CANErrCntrGet_CallbackFunctionPointer = Callback;
}

void CANErrCntrGet_Stub(CMOCK_CANErrCntrGet_CALLBACK Callback)
{
  Mock.CANErrCntrGet_IgnoreBool = (char)0;
  Mock.CANErrCntrGet_CallbackBool = (char)0;
  Mock.CANErrCntrGet_CallbackFunctionPointer = Callback;
}

void CANErrCntrGet_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint32 ui32Base, uint32* pui32RxCount, int pui32RxCount_Depth, uint32* pui32TxCount, int pui32TxCount_Depth, boolean cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_CANErrCntrGet_CALL_INSTANCE));
  CMOCK_CANErrCntrGet_CALL_INSTANCE* cmock_call_instance = (CMOCK_CANErrCntrGet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.CANErrCntrGet_CallInstance = CMock_Guts_MemChain(Mock.CANErrCntrGet_CallInstance, cmock_guts_index);
  Mock.CANErrCntrGet_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_CANErrCntrGet(cmock_call_instance, ui32Base, pui32RxCount, pui32RxCount_Depth, pui32TxCount, pui32TxCount_Depth);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void CANErrCntrGet_CMockReturnMemThruPtr_pui32RxCount(UNITY_LINE_TYPE cmock_line, uint32 const* pui32RxCount, size_t cmock_size)
{
  CMOCK_CANErrCntrGet_CALL_INSTANCE* cmock_call_instance = (CMOCK_CANErrCntrGet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.CANErrCntrGet_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_pui32RxCount_Used = 1;
  cmock_call_instance->ReturnThruPtr_pui32RxCount_Val = pui32RxCount;
  cmock_call_instance->ReturnThruPtr_pui32RxCount_Size = cmock_size;
}

void CANErrCntrGet_CMockReturnMemThruPtr_pui32TxCount(UNITY_LINE_TYPE cmock_line, uint32 const* pui32TxCount, size_t cmock_size)
{
  CMOCK_CANErrCntrGet_CALL_INSTANCE* cmock_call_instance = (CMOCK_CANErrCntrGet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.CANErrCntrGet_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_pui32TxCount_Used = 1;
  cmock_call_instance->ReturnThruPtr_pui32TxCount_Val = pui32TxCount;
  cmock_call_instance->ReturnThruPtr_pui32TxCount_Size = cmock_size;
}

void CANErrCntrGet_CMockIgnoreArg_ui32Base(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_CANErrCntrGet_CALL_INSTANCE* cmock_call_instance = (CMOCK_CANErrCntrGet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.CANErrCntrGet_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_ui32Base = 1;
}

void CANErrCntrGet_CMockIgnoreArg_pui32RxCount(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_CANErrCntrGet_CALL_INSTANCE* cmock_call_instance = (CMOCK_CANErrCntrGet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.CANErrCntrGet_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pui32RxCount = 1;
}

void CANErrCntrGet_CMockIgnoreArg_pui32TxCount(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_CANErrCntrGet_CALL_INSTANCE* cmock_call_instance = (CMOCK_CANErrCntrGet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.CANErrCntrGet_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pui32TxCount = 1;
}

void CANInit(uint32 ui32Base)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_CANInit_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_CANInit);
  cmock_call_instance = (CMOCK_CANInit_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.CANInit_CallInstance);
  Mock.CANInit_CallInstance = CMock_Guts_MemNext(Mock.CANInit_CallInstance);
  if (Mock.CANInit_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.CANInit_CallbackBool &&
      Mock.CANInit_CallbackFunctionPointer != NULL)
  {
    Mock.CANInit_CallbackFunctionPointer(ui32Base, Mock.CANInit_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_ui32Base)
  {
    UNITY_SET_DETAILS(CMockString_CANInit,CMockString_ui32Base);
    UNITY_TEST_ASSERT_EQUAL_UINT32(cmock_call_instance->Expected_ui32Base, ui32Base, cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.CANInit_CallbackFunctionPointer != NULL)
  {
    Mock.CANInit_CallbackFunctionPointer(ui32Base, Mock.CANInit_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_CANInit(CMOCK_CANInit_CALL_INSTANCE* cmock_call_instance, uint32 ui32Base);
void CMockExpectParameters_CANInit(CMOCK_CANInit_CALL_INSTANCE* cmock_call_instance, uint32 ui32Base)
{
  cmock_call_instance->Expected_ui32Base = ui32Base;
  cmock_call_instance->IgnoreArg_ui32Base = 0;
}

void CANInit_CMockIgnore(void)
{
  Mock.CANInit_IgnoreBool = (char)1;
}

void CANInit_CMockStopIgnore(void)
{
  Mock.CANInit_IgnoreBool = (char)0;
}

void CANInit_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_CANInit_CALL_INSTANCE));
  CMOCK_CANInit_CALL_INSTANCE* cmock_call_instance = (CMOCK_CANInit_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.CANInit_CallInstance = CMock_Guts_MemChain(Mock.CANInit_CallInstance, cmock_guts_index);
  Mock.CANInit_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void CANInit_CMockExpect(UNITY_LINE_TYPE cmock_line, uint32 ui32Base)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_CANInit_CALL_INSTANCE));
  CMOCK_CANInit_CALL_INSTANCE* cmock_call_instance = (CMOCK_CANInit_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.CANInit_CallInstance = CMock_Guts_MemChain(Mock.CANInit_CallInstance, cmock_guts_index);
  Mock.CANInit_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_CANInit(cmock_call_instance, ui32Base);
}

void CANInit_AddCallback(CMOCK_CANInit_CALLBACK Callback)
{
  Mock.CANInit_IgnoreBool = (char)0;
  Mock.CANInit_CallbackBool = (char)1;
  Mock.CANInit_CallbackFunctionPointer = Callback;
}

void CANInit_Stub(CMOCK_CANInit_CALLBACK Callback)
{
  Mock.CANInit_IgnoreBool = (char)0;
  Mock.CANInit_CallbackBool = (char)0;
  Mock.CANInit_CallbackFunctionPointer = Callback;
}

void CANInit_CMockIgnoreArg_ui32Base(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_CANInit_CALL_INSTANCE* cmock_call_instance = (CMOCK_CANInit_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.CANInit_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_ui32Base = 1;
}

void CANIntClear(uint32 ui32Base, uint32 ui32IntClr)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_CANIntClear_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_CANIntClear);
  cmock_call_instance = (CMOCK_CANIntClear_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.CANIntClear_CallInstance);
  Mock.CANIntClear_CallInstance = CMock_Guts_MemNext(Mock.CANIntClear_CallInstance);
  if (Mock.CANIntClear_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.CANIntClear_CallbackBool &&
      Mock.CANIntClear_CallbackFunctionPointer != NULL)
  {
    Mock.CANIntClear_CallbackFunctionPointer(ui32Base, ui32IntClr, Mock.CANIntClear_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_ui32Base)
  {
    UNITY_SET_DETAILS(CMockString_CANIntClear,CMockString_ui32Base);
    UNITY_TEST_ASSERT_EQUAL_UINT32(cmock_call_instance->Expected_ui32Base, ui32Base, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_ui32IntClr)
  {
    UNITY_SET_DETAILS(CMockString_CANIntClear,CMockString_ui32IntClr);
    UNITY_TEST_ASSERT_EQUAL_UINT32(cmock_call_instance->Expected_ui32IntClr, ui32IntClr, cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.CANIntClear_CallbackFunctionPointer != NULL)
  {
    Mock.CANIntClear_CallbackFunctionPointer(ui32Base, ui32IntClr, Mock.CANIntClear_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_CANIntClear(CMOCK_CANIntClear_CALL_INSTANCE* cmock_call_instance, uint32 ui32Base, uint32 ui32IntClr);
void CMockExpectParameters_CANIntClear(CMOCK_CANIntClear_CALL_INSTANCE* cmock_call_instance, uint32 ui32Base, uint32 ui32IntClr)
{
  cmock_call_instance->Expected_ui32Base = ui32Base;
  cmock_call_instance->IgnoreArg_ui32Base = 0;
  cmock_call_instance->Expected_ui32IntClr = ui32IntClr;
  cmock_call_instance->IgnoreArg_ui32IntClr = 0;
}

void CANIntClear_CMockIgnore(void)
{
  Mock.CANIntClear_IgnoreBool = (char)1;
}

void CANIntClear_CMockStopIgnore(void)
{
  Mock.CANIntClear_IgnoreBool = (char)0;
}

void CANIntClear_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_CANIntClear_CALL_INSTANCE));
  CMOCK_CANIntClear_CALL_INSTANCE* cmock_call_instance = (CMOCK_CANIntClear_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.CANIntClear_CallInstance = CMock_Guts_MemChain(Mock.CANIntClear_CallInstance, cmock_guts_index);
  Mock.CANIntClear_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void CANIntClear_CMockExpect(UNITY_LINE_TYPE cmock_line, uint32 ui32Base, uint32 ui32IntClr)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_CANIntClear_CALL_INSTANCE));
  CMOCK_CANIntClear_CALL_INSTANCE* cmock_call_instance = (CMOCK_CANIntClear_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.CANIntClear_CallInstance = CMock_Guts_MemChain(Mock.CANIntClear_CallInstance, cmock_guts_index);
  Mock.CANIntClear_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_CANIntClear(cmock_call_instance, ui32Base, ui32IntClr);
}

void CANIntClear_AddCallback(CMOCK_CANIntClear_CALLBACK Callback)
{
  Mock.CANIntClear_IgnoreBool = (char)0;
  Mock.CANIntClear_CallbackBool = (char)1;
  Mock.CANIntClear_CallbackFunctionPointer = Callback;
}

void CANIntClear_Stub(CMOCK_CANIntClear_CALLBACK Callback)
{
  Mock.CANIntClear_IgnoreBool = (char)0;
  Mock.CANIntClear_CallbackBool = (char)0;
  Mock.CANIntClear_CallbackFunctionPointer = Callback;
}

void CANIntClear_CMockIgnoreArg_ui32Base(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_CANIntClear_CALL_INSTANCE* cmock_call_instance = (CMOCK_CANIntClear_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.CANIntClear_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_ui32Base = 1;
}

void CANIntClear_CMockIgnoreArg_ui32IntClr(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_CANIntClear_CALL_INSTANCE* cmock_call_instance = (CMOCK_CANIntClear_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.CANIntClear_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_ui32IntClr = 1;
}

void CANIntDisable(uint32 ui32Base, uint32 ui32IntFlags)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_CANIntDisable_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_CANIntDisable);
  cmock_call_instance = (CMOCK_CANIntDisable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.CANIntDisable_CallInstance);
  Mock.CANIntDisable_CallInstance = CMock_Guts_MemNext(Mock.CANIntDisable_CallInstance);
  if (Mock.CANIntDisable_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.CANIntDisable_CallbackBool &&
      Mock.CANIntDisable_CallbackFunctionPointer != NULL)
  {
    Mock.CANIntDisable_CallbackFunctionPointer(ui32Base, ui32IntFlags, Mock.CANIntDisable_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_ui32Base)
  {
    UNITY_SET_DETAILS(CMockString_CANIntDisable,CMockString_ui32Base);
    UNITY_TEST_ASSERT_EQUAL_UINT32(cmock_call_instance->Expected_ui32Base, ui32Base, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_ui32IntFlags)
  {
    UNITY_SET_DETAILS(CMockString_CANIntDisable,CMockString_ui32IntFlags);
    UNITY_TEST_ASSERT_EQUAL_UINT32(cmock_call_instance->Expected_ui32IntFlags, ui32IntFlags, cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.CANIntDisable_CallbackFunctionPointer != NULL)
  {
    Mock.CANIntDisable_CallbackFunctionPointer(ui32Base, ui32IntFlags, Mock.CANIntDisable_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_CANIntDisable(CMOCK_CANIntDisable_CALL_INSTANCE* cmock_call_instance, uint32 ui32Base, uint32 ui32IntFlags);
void CMockExpectParameters_CANIntDisable(CMOCK_CANIntDisable_CALL_INSTANCE* cmock_call_instance, uint32 ui32Base, uint32 ui32IntFlags)
{
  cmock_call_instance->Expected_ui32Base = ui32Base;
  cmock_call_instance->IgnoreArg_ui32Base = 0;
  cmock_call_instance->Expected_ui32IntFlags = ui32IntFlags;
  cmock_call_instance->IgnoreArg_ui32IntFlags = 0;
}

void CANIntDisable_CMockIgnore(void)
{
  Mock.CANIntDisable_IgnoreBool = (char)1;
}

void CANIntDisable_CMockStopIgnore(void)
{
  Mock.CANIntDisable_IgnoreBool = (char)0;
}

void CANIntDisable_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_CANIntDisable_CALL_INSTANCE));
  CMOCK_CANIntDisable_CALL_INSTANCE* cmock_call_instance = (CMOCK_CANIntDisable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.CANIntDisable_CallInstance = CMock_Guts_MemChain(Mock.CANIntDisable_CallInstance, cmock_guts_index);
  Mock.CANIntDisable_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void CANIntDisable_CMockExpect(UNITY_LINE_TYPE cmock_line, uint32 ui32Base, uint32 ui32IntFlags)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_CANIntDisable_CALL_INSTANCE));
  CMOCK_CANIntDisable_CALL_INSTANCE* cmock_call_instance = (CMOCK_CANIntDisable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.CANIntDisable_CallInstance = CMock_Guts_MemChain(Mock.CANIntDisable_CallInstance, cmock_guts_index);
  Mock.CANIntDisable_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_CANIntDisable(cmock_call_instance, ui32Base, ui32IntFlags);
}

void CANIntDisable_AddCallback(CMOCK_CANIntDisable_CALLBACK Callback)
{
  Mock.CANIntDisable_IgnoreBool = (char)0;
  Mock.CANIntDisable_CallbackBool = (char)1;
  Mock.CANIntDisable_CallbackFunctionPointer = Callback;
}

void CANIntDisable_Stub(CMOCK_CANIntDisable_CALLBACK Callback)
{
  Mock.CANIntDisable_IgnoreBool = (char)0;
  Mock.CANIntDisable_CallbackBool = (char)0;
  Mock.CANIntDisable_CallbackFunctionPointer = Callback;
}

void CANIntDisable_CMockIgnoreArg_ui32Base(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_CANIntDisable_CALL_INSTANCE* cmock_call_instance = (CMOCK_CANIntDisable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.CANIntDisable_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_ui32Base = 1;
}

void CANIntDisable_CMockIgnoreArg_ui32IntFlags(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_CANIntDisable_CALL_INSTANCE* cmock_call_instance = (CMOCK_CANIntDisable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.CANIntDisable_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_ui32IntFlags = 1;
}

void CANIntEnable(uint32 ui32Base, uint32 ui32IntFlags)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_CANIntEnable_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_CANIntEnable);
  cmock_call_instance = (CMOCK_CANIntEnable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.CANIntEnable_CallInstance);
  Mock.CANIntEnable_CallInstance = CMock_Guts_MemNext(Mock.CANIntEnable_CallInstance);
  if (Mock.CANIntEnable_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.CANIntEnable_CallbackBool &&
      Mock.CANIntEnable_CallbackFunctionPointer != NULL)
  {
    Mock.CANIntEnable_CallbackFunctionPointer(ui32Base, ui32IntFlags, Mock.CANIntEnable_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_ui32Base)
  {
    UNITY_SET_DETAILS(CMockString_CANIntEnable,CMockString_ui32Base);
    UNITY_TEST_ASSERT_EQUAL_UINT32(cmock_call_instance->Expected_ui32Base, ui32Base, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_ui32IntFlags)
  {
    UNITY_SET_DETAILS(CMockString_CANIntEnable,CMockString_ui32IntFlags);
    UNITY_TEST_ASSERT_EQUAL_UINT32(cmock_call_instance->Expected_ui32IntFlags, ui32IntFlags, cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.CANIntEnable_CallbackFunctionPointer != NULL)
  {
    Mock.CANIntEnable_CallbackFunctionPointer(ui32Base, ui32IntFlags, Mock.CANIntEnable_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_CANIntEnable(CMOCK_CANIntEnable_CALL_INSTANCE* cmock_call_instance, uint32 ui32Base, uint32 ui32IntFlags);
void CMockExpectParameters_CANIntEnable(CMOCK_CANIntEnable_CALL_INSTANCE* cmock_call_instance, uint32 ui32Base, uint32 ui32IntFlags)
{
  cmock_call_instance->Expected_ui32Base = ui32Base;
  cmock_call_instance->IgnoreArg_ui32Base = 0;
  cmock_call_instance->Expected_ui32IntFlags = ui32IntFlags;
  cmock_call_instance->IgnoreArg_ui32IntFlags = 0;
}

void CANIntEnable_CMockIgnore(void)
{
  Mock.CANIntEnable_IgnoreBool = (char)1;
}

void CANIntEnable_CMockStopIgnore(void)
{
  Mock.CANIntEnable_IgnoreBool = (char)0;
}

void CANIntEnable_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_CANIntEnable_CALL_INSTANCE));
  CMOCK_CANIntEnable_CALL_INSTANCE* cmock_call_instance = (CMOCK_CANIntEnable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.CANIntEnable_CallInstance = CMock_Guts_MemChain(Mock.CANIntEnable_CallInstance, cmock_guts_index);
  Mock.CANIntEnable_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void CANIntEnable_CMockExpect(UNITY_LINE_TYPE cmock_line, uint32 ui32Base, uint32 ui32IntFlags)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_CANIntEnable_CALL_INSTANCE));
  CMOCK_CANIntEnable_CALL_INSTANCE* cmock_call_instance = (CMOCK_CANIntEnable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.CANIntEnable_CallInstance = CMock_Guts_MemChain(Mock.CANIntEnable_CallInstance, cmock_guts_index);
  Mock.CANIntEnable_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_CANIntEnable(cmock_call_instance, ui32Base, ui32IntFlags);
}

void CANIntEnable_AddCallback(CMOCK_CANIntEnable_CALLBACK Callback)
{
  Mock.CANIntEnable_IgnoreBool = (char)0;
  Mock.CANIntEnable_CallbackBool = (char)1;
  Mock.CANIntEnable_CallbackFunctionPointer = Callback;
}

void CANIntEnable_Stub(CMOCK_CANIntEnable_CALLBACK Callback)
{
  Mock.CANIntEnable_IgnoreBool = (char)0;
  Mock.CANIntEnable_CallbackBool = (char)0;
  Mock.CANIntEnable_CallbackFunctionPointer = Callback;
}

void CANIntEnable_CMockIgnoreArg_ui32Base(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_CANIntEnable_CALL_INSTANCE* cmock_call_instance = (CMOCK_CANIntEnable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.CANIntEnable_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_ui32Base = 1;
}

void CANIntEnable_CMockIgnoreArg_ui32IntFlags(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_CANIntEnable_CALL_INSTANCE* cmock_call_instance = (CMOCK_CANIntEnable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.CANIntEnable_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_ui32IntFlags = 1;
}

void CANIntRegister(uint32 ui32Base, cmock_can_lib_func_ptr1 pfnHandler)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_CANIntRegister_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_CANIntRegister);
  cmock_call_instance = (CMOCK_CANIntRegister_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.CANIntRegister_CallInstance);
  Mock.CANIntRegister_CallInstance = CMock_Guts_MemNext(Mock.CANIntRegister_CallInstance);
  if (Mock.CANIntRegister_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.CANIntRegister_CallbackBool &&
      Mock.CANIntRegister_CallbackFunctionPointer != NULL)
  {
    Mock.CANIntRegister_CallbackFunctionPointer(ui32Base, pfnHandler, Mock.CANIntRegister_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_ui32Base)
  {
    UNITY_SET_DETAILS(CMockString_CANIntRegister,CMockString_ui32Base);
    UNITY_TEST_ASSERT_EQUAL_UINT32(cmock_call_instance->Expected_ui32Base, ui32Base, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_pfnHandler)
  {
    UNITY_SET_DETAILS(CMockString_CANIntRegister,CMockString_pfnHandler);
    UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_pfnHandler, pfnHandler, cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.CANIntRegister_CallbackFunctionPointer != NULL)
  {
    Mock.CANIntRegister_CallbackFunctionPointer(ui32Base, pfnHandler, Mock.CANIntRegister_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_CANIntRegister(CMOCK_CANIntRegister_CALL_INSTANCE* cmock_call_instance, uint32 ui32Base, cmock_can_lib_func_ptr1 pfnHandler);
void CMockExpectParameters_CANIntRegister(CMOCK_CANIntRegister_CALL_INSTANCE* cmock_call_instance, uint32 ui32Base, cmock_can_lib_func_ptr1 pfnHandler)
{
  cmock_call_instance->Expected_ui32Base = ui32Base;
  cmock_call_instance->IgnoreArg_ui32Base = 0;
  memcpy((void*)(&cmock_call_instance->Expected_pfnHandler), (void*)(&pfnHandler),
         sizeof(cmock_can_lib_func_ptr1[sizeof(pfnHandler) == sizeof(cmock_can_lib_func_ptr1) ? 1 : -1])); /* add cmock_can_lib_func_ptr1 to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_pfnHandler = 0;
}

void CANIntRegister_CMockIgnore(void)
{
  Mock.CANIntRegister_IgnoreBool = (char)1;
}

void CANIntRegister_CMockStopIgnore(void)
{
  Mock.CANIntRegister_IgnoreBool = (char)0;
}

void CANIntRegister_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_CANIntRegister_CALL_INSTANCE));
  CMOCK_CANIntRegister_CALL_INSTANCE* cmock_call_instance = (CMOCK_CANIntRegister_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.CANIntRegister_CallInstance = CMock_Guts_MemChain(Mock.CANIntRegister_CallInstance, cmock_guts_index);
  Mock.CANIntRegister_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void CANIntRegister_CMockExpect(UNITY_LINE_TYPE cmock_line, uint32 ui32Base, cmock_can_lib_func_ptr1 pfnHandler)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_CANIntRegister_CALL_INSTANCE));
  CMOCK_CANIntRegister_CALL_INSTANCE* cmock_call_instance = (CMOCK_CANIntRegister_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.CANIntRegister_CallInstance = CMock_Guts_MemChain(Mock.CANIntRegister_CallInstance, cmock_guts_index);
  Mock.CANIntRegister_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_CANIntRegister(cmock_call_instance, ui32Base, pfnHandler);
}

void CANIntRegister_AddCallback(CMOCK_CANIntRegister_CALLBACK Callback)
{
  Mock.CANIntRegister_IgnoreBool = (char)0;
  Mock.CANIntRegister_CallbackBool = (char)1;
  Mock.CANIntRegister_CallbackFunctionPointer = Callback;
}

void CANIntRegister_Stub(CMOCK_CANIntRegister_CALLBACK Callback)
{
  Mock.CANIntRegister_IgnoreBool = (char)0;
  Mock.CANIntRegister_CallbackBool = (char)0;
  Mock.CANIntRegister_CallbackFunctionPointer = Callback;
}

void CANIntRegister_CMockIgnoreArg_ui32Base(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_CANIntRegister_CALL_INSTANCE* cmock_call_instance = (CMOCK_CANIntRegister_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.CANIntRegister_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_ui32Base = 1;
}

void CANIntRegister_CMockIgnoreArg_pfnHandler(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_CANIntRegister_CALL_INSTANCE* cmock_call_instance = (CMOCK_CANIntRegister_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.CANIntRegister_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pfnHandler = 1;
}

uint32 CANIntStatus(uint32 ui32Base, tCANIntStsReg eIntStsReg)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_CANIntStatus_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_CANIntStatus);
  cmock_call_instance = (CMOCK_CANIntStatus_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.CANIntStatus_CallInstance);
  Mock.CANIntStatus_CallInstance = CMock_Guts_MemNext(Mock.CANIntStatus_CallInstance);
  if (Mock.CANIntStatus_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.CANIntStatus_FinalReturn;
    Mock.CANIntStatus_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.CANIntStatus_CallbackBool &&
      Mock.CANIntStatus_CallbackFunctionPointer != NULL)
  {
    uint32 cmock_cb_ret = Mock.CANIntStatus_CallbackFunctionPointer(ui32Base, eIntStsReg, Mock.CANIntStatus_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_ui32Base)
  {
    UNITY_SET_DETAILS(CMockString_CANIntStatus,CMockString_ui32Base);
    UNITY_TEST_ASSERT_EQUAL_UINT32(cmock_call_instance->Expected_ui32Base, ui32Base, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_eIntStsReg)
  {
    UNITY_SET_DETAILS(CMockString_CANIntStatus,CMockString_eIntStsReg);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_eIntStsReg), (void*)(&eIntStsReg), sizeof(tCANIntStsReg), cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.CANIntStatus_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.CANIntStatus_CallbackFunctionPointer(ui32Base, eIntStsReg, Mock.CANIntStatus_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_CANIntStatus(CMOCK_CANIntStatus_CALL_INSTANCE* cmock_call_instance, uint32 ui32Base, tCANIntStsReg eIntStsReg);
void CMockExpectParameters_CANIntStatus(CMOCK_CANIntStatus_CALL_INSTANCE* cmock_call_instance, uint32 ui32Base, tCANIntStsReg eIntStsReg)
{
  cmock_call_instance->Expected_ui32Base = ui32Base;
  cmock_call_instance->IgnoreArg_ui32Base = 0;
  memcpy((void*)(&cmock_call_instance->Expected_eIntStsReg), (void*)(&eIntStsReg),
         sizeof(tCANIntStsReg[sizeof(eIntStsReg) == sizeof(tCANIntStsReg) ? 1 : -1])); /* add tCANIntStsReg to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_eIntStsReg = 0;
}

void CANIntStatus_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32 cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_CANIntStatus_CALL_INSTANCE));
  CMOCK_CANIntStatus_CALL_INSTANCE* cmock_call_instance = (CMOCK_CANIntStatus_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.CANIntStatus_CallInstance = CMock_Guts_MemChain(Mock.CANIntStatus_CallInstance, cmock_guts_index);
  Mock.CANIntStatus_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.CANIntStatus_IgnoreBool = (char)1;
}

void CANIntStatus_CMockStopIgnore(void)
{
  if(Mock.CANIntStatus_IgnoreBool)
    Mock.CANIntStatus_CallInstance = CMock_Guts_MemNext(Mock.CANIntStatus_CallInstance);
  Mock.CANIntStatus_IgnoreBool = (char)0;
}

void CANIntStatus_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, uint32 cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_CANIntStatus_CALL_INSTANCE));
  CMOCK_CANIntStatus_CALL_INSTANCE* cmock_call_instance = (CMOCK_CANIntStatus_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.CANIntStatus_CallInstance = CMock_Guts_MemChain(Mock.CANIntStatus_CallInstance, cmock_guts_index);
  Mock.CANIntStatus_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void CANIntStatus_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32 ui32Base, tCANIntStsReg eIntStsReg, uint32 cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_CANIntStatus_CALL_INSTANCE));
  CMOCK_CANIntStatus_CALL_INSTANCE* cmock_call_instance = (CMOCK_CANIntStatus_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.CANIntStatus_CallInstance = CMock_Guts_MemChain(Mock.CANIntStatus_CallInstance, cmock_guts_index);
  Mock.CANIntStatus_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_CANIntStatus(cmock_call_instance, ui32Base, eIntStsReg);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void CANIntStatus_AddCallback(CMOCK_CANIntStatus_CALLBACK Callback)
{
  Mock.CANIntStatus_IgnoreBool = (char)0;
  Mock.CANIntStatus_CallbackBool = (char)1;
  Mock.CANIntStatus_CallbackFunctionPointer = Callback;
}

void CANIntStatus_Stub(CMOCK_CANIntStatus_CALLBACK Callback)
{
  Mock.CANIntStatus_IgnoreBool = (char)0;
  Mock.CANIntStatus_CallbackBool = (char)0;
  Mock.CANIntStatus_CallbackFunctionPointer = Callback;
}

void CANIntStatus_CMockIgnoreArg_ui32Base(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_CANIntStatus_CALL_INSTANCE* cmock_call_instance = (CMOCK_CANIntStatus_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.CANIntStatus_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_ui32Base = 1;
}

void CANIntStatus_CMockIgnoreArg_eIntStsReg(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_CANIntStatus_CALL_INSTANCE* cmock_call_instance = (CMOCK_CANIntStatus_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.CANIntStatus_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_eIntStsReg = 1;
}

void CANIntUnregister(uint32 ui32Base)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_CANIntUnregister_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_CANIntUnregister);
  cmock_call_instance = (CMOCK_CANIntUnregister_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.CANIntUnregister_CallInstance);
  Mock.CANIntUnregister_CallInstance = CMock_Guts_MemNext(Mock.CANIntUnregister_CallInstance);
  if (Mock.CANIntUnregister_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.CANIntUnregister_CallbackBool &&
      Mock.CANIntUnregister_CallbackFunctionPointer != NULL)
  {
    Mock.CANIntUnregister_CallbackFunctionPointer(ui32Base, Mock.CANIntUnregister_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_ui32Base)
  {
    UNITY_SET_DETAILS(CMockString_CANIntUnregister,CMockString_ui32Base);
    UNITY_TEST_ASSERT_EQUAL_UINT32(cmock_call_instance->Expected_ui32Base, ui32Base, cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.CANIntUnregister_CallbackFunctionPointer != NULL)
  {
    Mock.CANIntUnregister_CallbackFunctionPointer(ui32Base, Mock.CANIntUnregister_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_CANIntUnregister(CMOCK_CANIntUnregister_CALL_INSTANCE* cmock_call_instance, uint32 ui32Base);
void CMockExpectParameters_CANIntUnregister(CMOCK_CANIntUnregister_CALL_INSTANCE* cmock_call_instance, uint32 ui32Base)
{
  cmock_call_instance->Expected_ui32Base = ui32Base;
  cmock_call_instance->IgnoreArg_ui32Base = 0;
}

void CANIntUnregister_CMockIgnore(void)
{
  Mock.CANIntUnregister_IgnoreBool = (char)1;
}

void CANIntUnregister_CMockStopIgnore(void)
{
  Mock.CANIntUnregister_IgnoreBool = (char)0;
}

void CANIntUnregister_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_CANIntUnregister_CALL_INSTANCE));
  CMOCK_CANIntUnregister_CALL_INSTANCE* cmock_call_instance = (CMOCK_CANIntUnregister_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.CANIntUnregister_CallInstance = CMock_Guts_MemChain(Mock.CANIntUnregister_CallInstance, cmock_guts_index);
  Mock.CANIntUnregister_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void CANIntUnregister_CMockExpect(UNITY_LINE_TYPE cmock_line, uint32 ui32Base)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_CANIntUnregister_CALL_INSTANCE));
  CMOCK_CANIntUnregister_CALL_INSTANCE* cmock_call_instance = (CMOCK_CANIntUnregister_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.CANIntUnregister_CallInstance = CMock_Guts_MemChain(Mock.CANIntUnregister_CallInstance, cmock_guts_index);
  Mock.CANIntUnregister_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_CANIntUnregister(cmock_call_instance, ui32Base);
}

void CANIntUnregister_AddCallback(CMOCK_CANIntUnregister_CALLBACK Callback)
{
  Mock.CANIntUnregister_IgnoreBool = (char)0;
  Mock.CANIntUnregister_CallbackBool = (char)1;
  Mock.CANIntUnregister_CallbackFunctionPointer = Callback;
}

void CANIntUnregister_Stub(CMOCK_CANIntUnregister_CALLBACK Callback)
{
  Mock.CANIntUnregister_IgnoreBool = (char)0;
  Mock.CANIntUnregister_CallbackBool = (char)0;
  Mock.CANIntUnregister_CallbackFunctionPointer = Callback;
}

void CANIntUnregister_CMockIgnoreArg_ui32Base(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_CANIntUnregister_CALL_INSTANCE* cmock_call_instance = (CMOCK_CANIntUnregister_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.CANIntUnregister_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_ui32Base = 1;
}

void CANMessageClear(uint32 ui32Base, uint32 ui32ObjID)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_CANMessageClear_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_CANMessageClear);
  cmock_call_instance = (CMOCK_CANMessageClear_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.CANMessageClear_CallInstance);
  Mock.CANMessageClear_CallInstance = CMock_Guts_MemNext(Mock.CANMessageClear_CallInstance);
  if (Mock.CANMessageClear_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.CANMessageClear_CallbackBool &&
      Mock.CANMessageClear_CallbackFunctionPointer != NULL)
  {
    Mock.CANMessageClear_CallbackFunctionPointer(ui32Base, ui32ObjID, Mock.CANMessageClear_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_ui32Base)
  {
    UNITY_SET_DETAILS(CMockString_CANMessageClear,CMockString_ui32Base);
    UNITY_TEST_ASSERT_EQUAL_UINT32(cmock_call_instance->Expected_ui32Base, ui32Base, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_ui32ObjID)
  {
    UNITY_SET_DETAILS(CMockString_CANMessageClear,CMockString_ui32ObjID);
    UNITY_TEST_ASSERT_EQUAL_UINT32(cmock_call_instance->Expected_ui32ObjID, ui32ObjID, cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.CANMessageClear_CallbackFunctionPointer != NULL)
  {
    Mock.CANMessageClear_CallbackFunctionPointer(ui32Base, ui32ObjID, Mock.CANMessageClear_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_CANMessageClear(CMOCK_CANMessageClear_CALL_INSTANCE* cmock_call_instance, uint32 ui32Base, uint32 ui32ObjID);
void CMockExpectParameters_CANMessageClear(CMOCK_CANMessageClear_CALL_INSTANCE* cmock_call_instance, uint32 ui32Base, uint32 ui32ObjID)
{
  cmock_call_instance->Expected_ui32Base = ui32Base;
  cmock_call_instance->IgnoreArg_ui32Base = 0;
  cmock_call_instance->Expected_ui32ObjID = ui32ObjID;
  cmock_call_instance->IgnoreArg_ui32ObjID = 0;
}

void CANMessageClear_CMockIgnore(void)
{
  Mock.CANMessageClear_IgnoreBool = (char)1;
}

void CANMessageClear_CMockStopIgnore(void)
{
  Mock.CANMessageClear_IgnoreBool = (char)0;
}

void CANMessageClear_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_CANMessageClear_CALL_INSTANCE));
  CMOCK_CANMessageClear_CALL_INSTANCE* cmock_call_instance = (CMOCK_CANMessageClear_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.CANMessageClear_CallInstance = CMock_Guts_MemChain(Mock.CANMessageClear_CallInstance, cmock_guts_index);
  Mock.CANMessageClear_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void CANMessageClear_CMockExpect(UNITY_LINE_TYPE cmock_line, uint32 ui32Base, uint32 ui32ObjID)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_CANMessageClear_CALL_INSTANCE));
  CMOCK_CANMessageClear_CALL_INSTANCE* cmock_call_instance = (CMOCK_CANMessageClear_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.CANMessageClear_CallInstance = CMock_Guts_MemChain(Mock.CANMessageClear_CallInstance, cmock_guts_index);
  Mock.CANMessageClear_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_CANMessageClear(cmock_call_instance, ui32Base, ui32ObjID);
}

void CANMessageClear_AddCallback(CMOCK_CANMessageClear_CALLBACK Callback)
{
  Mock.CANMessageClear_IgnoreBool = (char)0;
  Mock.CANMessageClear_CallbackBool = (char)1;
  Mock.CANMessageClear_CallbackFunctionPointer = Callback;
}

void CANMessageClear_Stub(CMOCK_CANMessageClear_CALLBACK Callback)
{
  Mock.CANMessageClear_IgnoreBool = (char)0;
  Mock.CANMessageClear_CallbackBool = (char)0;
  Mock.CANMessageClear_CallbackFunctionPointer = Callback;
}

void CANMessageClear_CMockIgnoreArg_ui32Base(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_CANMessageClear_CALL_INSTANCE* cmock_call_instance = (CMOCK_CANMessageClear_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.CANMessageClear_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_ui32Base = 1;
}

void CANMessageClear_CMockIgnoreArg_ui32ObjID(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_CANMessageClear_CALL_INSTANCE* cmock_call_instance = (CMOCK_CANMessageClear_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.CANMessageClear_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_ui32ObjID = 1;
}

void CANMessageGet(uint32 ui32Base, uint32 ui32ObjID, tCANMsgObject* psMsgObject, boolean bClrPendingInt)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_CANMessageGet_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_CANMessageGet);
  cmock_call_instance = (CMOCK_CANMessageGet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.CANMessageGet_CallInstance);
  Mock.CANMessageGet_CallInstance = CMock_Guts_MemNext(Mock.CANMessageGet_CallInstance);
  if (Mock.CANMessageGet_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.CANMessageGet_CallbackBool &&
      Mock.CANMessageGet_CallbackFunctionPointer != NULL)
  {
    Mock.CANMessageGet_CallbackFunctionPointer(ui32Base, ui32ObjID, psMsgObject, bClrPendingInt, Mock.CANMessageGet_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_ui32Base)
  {
    UNITY_SET_DETAILS(CMockString_CANMessageGet,CMockString_ui32Base);
    UNITY_TEST_ASSERT_EQUAL_UINT32(cmock_call_instance->Expected_ui32Base, ui32Base, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_ui32ObjID)
  {
    UNITY_SET_DETAILS(CMockString_CANMessageGet,CMockString_ui32ObjID);
    UNITY_TEST_ASSERT_EQUAL_UINT32(cmock_call_instance->Expected_ui32ObjID, ui32ObjID, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_psMsgObject)
  {
    UNITY_SET_DETAILS(CMockString_CANMessageGet,CMockString_psMsgObject);
    if (cmock_call_instance->Expected_psMsgObject == NULL)
      { UNITY_TEST_ASSERT_NULL(psMsgObject, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_psMsgObject), (void*)(psMsgObject), sizeof(tCANMsgObject), cmock_call_instance->Expected_psMsgObject_Depth, cmock_line, CMockStringMismatch); }
  }
  if (!cmock_call_instance->IgnoreArg_bClrPendingInt)
  {
    UNITY_SET_DETAILS(CMockString_CANMessageGet,CMockString_bClrPendingInt);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_bClrPendingInt), (void*)(&bClrPendingInt), sizeof(boolean), cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.CANMessageGet_CallbackFunctionPointer != NULL)
  {
    Mock.CANMessageGet_CallbackFunctionPointer(ui32Base, ui32ObjID, psMsgObject, bClrPendingInt, Mock.CANMessageGet_CallbackCalls++);
  }
  if (cmock_call_instance->ReturnThruPtr_psMsgObject_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(psMsgObject, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)psMsgObject, (const void*)cmock_call_instance->ReturnThruPtr_psMsgObject_Val,
      cmock_call_instance->ReturnThruPtr_psMsgObject_Size);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_CANMessageGet(CMOCK_CANMessageGet_CALL_INSTANCE* cmock_call_instance, uint32 ui32Base, uint32 ui32ObjID, tCANMsgObject* psMsgObject, int psMsgObject_Depth, boolean bClrPendingInt);
void CMockExpectParameters_CANMessageGet(CMOCK_CANMessageGet_CALL_INSTANCE* cmock_call_instance, uint32 ui32Base, uint32 ui32ObjID, tCANMsgObject* psMsgObject, int psMsgObject_Depth, boolean bClrPendingInt)
{
  cmock_call_instance->Expected_ui32Base = ui32Base;
  cmock_call_instance->IgnoreArg_ui32Base = 0;
  cmock_call_instance->Expected_ui32ObjID = ui32ObjID;
  cmock_call_instance->IgnoreArg_ui32ObjID = 0;
  cmock_call_instance->Expected_psMsgObject = psMsgObject;
  cmock_call_instance->Expected_psMsgObject_Depth = psMsgObject_Depth;
  cmock_call_instance->IgnoreArg_psMsgObject = 0;
  cmock_call_instance->ReturnThruPtr_psMsgObject_Used = 0;
  memcpy((void*)(&cmock_call_instance->Expected_bClrPendingInt), (void*)(&bClrPendingInt),
         sizeof(boolean[sizeof(bClrPendingInt) == sizeof(boolean) ? 1 : -1])); /* add boolean to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_bClrPendingInt = 0;
}

void CANMessageGet_CMockIgnore(void)
{
  Mock.CANMessageGet_IgnoreBool = (char)1;
}

void CANMessageGet_CMockStopIgnore(void)
{
  Mock.CANMessageGet_IgnoreBool = (char)0;
}

void CANMessageGet_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_CANMessageGet_CALL_INSTANCE));
  CMOCK_CANMessageGet_CALL_INSTANCE* cmock_call_instance = (CMOCK_CANMessageGet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.CANMessageGet_CallInstance = CMock_Guts_MemChain(Mock.CANMessageGet_CallInstance, cmock_guts_index);
  Mock.CANMessageGet_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void CANMessageGet_CMockExpect(UNITY_LINE_TYPE cmock_line, uint32 ui32Base, uint32 ui32ObjID, tCANMsgObject* psMsgObject, boolean bClrPendingInt)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_CANMessageGet_CALL_INSTANCE));
  CMOCK_CANMessageGet_CALL_INSTANCE* cmock_call_instance = (CMOCK_CANMessageGet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.CANMessageGet_CallInstance = CMock_Guts_MemChain(Mock.CANMessageGet_CallInstance, cmock_guts_index);
  Mock.CANMessageGet_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_CANMessageGet(cmock_call_instance, ui32Base, ui32ObjID, psMsgObject, 1, bClrPendingInt);
}

void CANMessageGet_AddCallback(CMOCK_CANMessageGet_CALLBACK Callback)
{
  Mock.CANMessageGet_IgnoreBool = (char)0;
  Mock.CANMessageGet_CallbackBool = (char)1;
  Mock.CANMessageGet_CallbackFunctionPointer = Callback;
}

void CANMessageGet_Stub(CMOCK_CANMessageGet_CALLBACK Callback)
{
  Mock.CANMessageGet_IgnoreBool = (char)0;
  Mock.CANMessageGet_CallbackBool = (char)0;
  Mock.CANMessageGet_CallbackFunctionPointer = Callback;
}

void CANMessageGet_CMockExpectWithArray(UNITY_LINE_TYPE cmock_line, uint32 ui32Base, uint32 ui32ObjID, tCANMsgObject* psMsgObject, int psMsgObject_Depth, boolean bClrPendingInt)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_CANMessageGet_CALL_INSTANCE));
  CMOCK_CANMessageGet_CALL_INSTANCE* cmock_call_instance = (CMOCK_CANMessageGet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.CANMessageGet_CallInstance = CMock_Guts_MemChain(Mock.CANMessageGet_CallInstance, cmock_guts_index);
  Mock.CANMessageGet_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_CANMessageGet(cmock_call_instance, ui32Base, ui32ObjID, psMsgObject, psMsgObject_Depth, bClrPendingInt);
}

void CANMessageGet_CMockReturnMemThruPtr_psMsgObject(UNITY_LINE_TYPE cmock_line, tCANMsgObject const* psMsgObject, size_t cmock_size)
{
  CMOCK_CANMessageGet_CALL_INSTANCE* cmock_call_instance = (CMOCK_CANMessageGet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.CANMessageGet_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_psMsgObject_Used = 1;
  cmock_call_instance->ReturnThruPtr_psMsgObject_Val = psMsgObject;
  cmock_call_instance->ReturnThruPtr_psMsgObject_Size = cmock_size;
}

void CANMessageGet_CMockIgnoreArg_ui32Base(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_CANMessageGet_CALL_INSTANCE* cmock_call_instance = (CMOCK_CANMessageGet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.CANMessageGet_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_ui32Base = 1;
}

void CANMessageGet_CMockIgnoreArg_ui32ObjID(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_CANMessageGet_CALL_INSTANCE* cmock_call_instance = (CMOCK_CANMessageGet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.CANMessageGet_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_ui32ObjID = 1;
}

void CANMessageGet_CMockIgnoreArg_psMsgObject(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_CANMessageGet_CALL_INSTANCE* cmock_call_instance = (CMOCK_CANMessageGet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.CANMessageGet_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_psMsgObject = 1;
}

void CANMessageGet_CMockIgnoreArg_bClrPendingInt(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_CANMessageGet_CALL_INSTANCE* cmock_call_instance = (CMOCK_CANMessageGet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.CANMessageGet_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_bClrPendingInt = 1;
}

void CANMessageSet(uint32 ui32Base, uint32 ui32ObjID, tCANMsgObject* psMsgObject, tMsgObjType eMsgType)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_CANMessageSet_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_CANMessageSet);
  cmock_call_instance = (CMOCK_CANMessageSet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.CANMessageSet_CallInstance);
  Mock.CANMessageSet_CallInstance = CMock_Guts_MemNext(Mock.CANMessageSet_CallInstance);
  if (Mock.CANMessageSet_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.CANMessageSet_CallbackBool &&
      Mock.CANMessageSet_CallbackFunctionPointer != NULL)
  {
    Mock.CANMessageSet_CallbackFunctionPointer(ui32Base, ui32ObjID, psMsgObject, eMsgType, Mock.CANMessageSet_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_ui32Base)
  {
    UNITY_SET_DETAILS(CMockString_CANMessageSet,CMockString_ui32Base);
    UNITY_TEST_ASSERT_EQUAL_UINT32(cmock_call_instance->Expected_ui32Base, ui32Base, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_ui32ObjID)
  {
    UNITY_SET_DETAILS(CMockString_CANMessageSet,CMockString_ui32ObjID);
    UNITY_TEST_ASSERT_EQUAL_UINT32(cmock_call_instance->Expected_ui32ObjID, ui32ObjID, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_psMsgObject)
  {
    UNITY_SET_DETAILS(CMockString_CANMessageSet,CMockString_psMsgObject);
    if (cmock_call_instance->Expected_psMsgObject == NULL)
      { UNITY_TEST_ASSERT_NULL(psMsgObject, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_psMsgObject), (void*)(psMsgObject), sizeof(tCANMsgObject), cmock_call_instance->Expected_psMsgObject_Depth, cmock_line, CMockStringMismatch); }
  }
  if (!cmock_call_instance->IgnoreArg_eMsgType)
  {
    UNITY_SET_DETAILS(CMockString_CANMessageSet,CMockString_eMsgType);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_eMsgType), (void*)(&eMsgType), sizeof(tMsgObjType), cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.CANMessageSet_CallbackFunctionPointer != NULL)
  {
    Mock.CANMessageSet_CallbackFunctionPointer(ui32Base, ui32ObjID, psMsgObject, eMsgType, Mock.CANMessageSet_CallbackCalls++);
  }
  if (cmock_call_instance->ReturnThruPtr_psMsgObject_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(psMsgObject, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)psMsgObject, (const void*)cmock_call_instance->ReturnThruPtr_psMsgObject_Val,
      cmock_call_instance->ReturnThruPtr_psMsgObject_Size);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_CANMessageSet(CMOCK_CANMessageSet_CALL_INSTANCE* cmock_call_instance, uint32 ui32Base, uint32 ui32ObjID, tCANMsgObject* psMsgObject, int psMsgObject_Depth, tMsgObjType eMsgType);
void CMockExpectParameters_CANMessageSet(CMOCK_CANMessageSet_CALL_INSTANCE* cmock_call_instance, uint32 ui32Base, uint32 ui32ObjID, tCANMsgObject* psMsgObject, int psMsgObject_Depth, tMsgObjType eMsgType)
{
  cmock_call_instance->Expected_ui32Base = ui32Base;
  cmock_call_instance->IgnoreArg_ui32Base = 0;
  cmock_call_instance->Expected_ui32ObjID = ui32ObjID;
  cmock_call_instance->IgnoreArg_ui32ObjID = 0;
  cmock_call_instance->Expected_psMsgObject = psMsgObject;
  cmock_call_instance->Expected_psMsgObject_Depth = psMsgObject_Depth;
  cmock_call_instance->IgnoreArg_psMsgObject = 0;
  cmock_call_instance->ReturnThruPtr_psMsgObject_Used = 0;
  memcpy((void*)(&cmock_call_instance->Expected_eMsgType), (void*)(&eMsgType),
         sizeof(tMsgObjType[sizeof(eMsgType) == sizeof(tMsgObjType) ? 1 : -1])); /* add tMsgObjType to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_eMsgType = 0;
}

void CANMessageSet_CMockIgnore(void)
{
  Mock.CANMessageSet_IgnoreBool = (char)1;
}

void CANMessageSet_CMockStopIgnore(void)
{
  Mock.CANMessageSet_IgnoreBool = (char)0;
}

void CANMessageSet_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_CANMessageSet_CALL_INSTANCE));
  CMOCK_CANMessageSet_CALL_INSTANCE* cmock_call_instance = (CMOCK_CANMessageSet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.CANMessageSet_CallInstance = CMock_Guts_MemChain(Mock.CANMessageSet_CallInstance, cmock_guts_index);
  Mock.CANMessageSet_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void CANMessageSet_CMockExpect(UNITY_LINE_TYPE cmock_line, uint32 ui32Base, uint32 ui32ObjID, tCANMsgObject* psMsgObject, tMsgObjType eMsgType)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_CANMessageSet_CALL_INSTANCE));
  CMOCK_CANMessageSet_CALL_INSTANCE* cmock_call_instance = (CMOCK_CANMessageSet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.CANMessageSet_CallInstance = CMock_Guts_MemChain(Mock.CANMessageSet_CallInstance, cmock_guts_index);
  Mock.CANMessageSet_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_CANMessageSet(cmock_call_instance, ui32Base, ui32ObjID, psMsgObject, 1, eMsgType);
}

void CANMessageSet_AddCallback(CMOCK_CANMessageSet_CALLBACK Callback)
{
  Mock.CANMessageSet_IgnoreBool = (char)0;
  Mock.CANMessageSet_CallbackBool = (char)1;
  Mock.CANMessageSet_CallbackFunctionPointer = Callback;
}

void CANMessageSet_Stub(CMOCK_CANMessageSet_CALLBACK Callback)
{
  Mock.CANMessageSet_IgnoreBool = (char)0;
  Mock.CANMessageSet_CallbackBool = (char)0;
  Mock.CANMessageSet_CallbackFunctionPointer = Callback;
}

void CANMessageSet_CMockExpectWithArray(UNITY_LINE_TYPE cmock_line, uint32 ui32Base, uint32 ui32ObjID, tCANMsgObject* psMsgObject, int psMsgObject_Depth, tMsgObjType eMsgType)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_CANMessageSet_CALL_INSTANCE));
  CMOCK_CANMessageSet_CALL_INSTANCE* cmock_call_instance = (CMOCK_CANMessageSet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.CANMessageSet_CallInstance = CMock_Guts_MemChain(Mock.CANMessageSet_CallInstance, cmock_guts_index);
  Mock.CANMessageSet_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_CANMessageSet(cmock_call_instance, ui32Base, ui32ObjID, psMsgObject, psMsgObject_Depth, eMsgType);
}

void CANMessageSet_CMockReturnMemThruPtr_psMsgObject(UNITY_LINE_TYPE cmock_line, tCANMsgObject const* psMsgObject, size_t cmock_size)
{
  CMOCK_CANMessageSet_CALL_INSTANCE* cmock_call_instance = (CMOCK_CANMessageSet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.CANMessageSet_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_psMsgObject_Used = 1;
  cmock_call_instance->ReturnThruPtr_psMsgObject_Val = psMsgObject;
  cmock_call_instance->ReturnThruPtr_psMsgObject_Size = cmock_size;
}

void CANMessageSet_CMockIgnoreArg_ui32Base(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_CANMessageSet_CALL_INSTANCE* cmock_call_instance = (CMOCK_CANMessageSet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.CANMessageSet_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_ui32Base = 1;
}

void CANMessageSet_CMockIgnoreArg_ui32ObjID(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_CANMessageSet_CALL_INSTANCE* cmock_call_instance = (CMOCK_CANMessageSet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.CANMessageSet_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_ui32ObjID = 1;
}

void CANMessageSet_CMockIgnoreArg_psMsgObject(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_CANMessageSet_CALL_INSTANCE* cmock_call_instance = (CMOCK_CANMessageSet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.CANMessageSet_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_psMsgObject = 1;
}

void CANMessageSet_CMockIgnoreArg_eMsgType(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_CANMessageSet_CALL_INSTANCE* cmock_call_instance = (CMOCK_CANMessageSet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.CANMessageSet_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_eMsgType = 1;
}

boolean CANRetryGet(uint32 ui32Base)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_CANRetryGet_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_CANRetryGet);
  cmock_call_instance = (CMOCK_CANRetryGet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.CANRetryGet_CallInstance);
  Mock.CANRetryGet_CallInstance = CMock_Guts_MemNext(Mock.CANRetryGet_CallInstance);
  if (Mock.CANRetryGet_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.CANRetryGet_FinalReturn;
    memcpy((void*)(&Mock.CANRetryGet_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(boolean[sizeof(cmock_call_instance->ReturnVal) == sizeof(boolean) ? 1 : -1])); /* add boolean to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.CANRetryGet_CallbackBool &&
      Mock.CANRetryGet_CallbackFunctionPointer != NULL)
  {
    boolean cmock_cb_ret = Mock.CANRetryGet_CallbackFunctionPointer(ui32Base, Mock.CANRetryGet_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_ui32Base)
  {
    UNITY_SET_DETAILS(CMockString_CANRetryGet,CMockString_ui32Base);
    UNITY_TEST_ASSERT_EQUAL_UINT32(cmock_call_instance->Expected_ui32Base, ui32Base, cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.CANRetryGet_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.CANRetryGet_CallbackFunctionPointer(ui32Base, Mock.CANRetryGet_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_CANRetryGet(CMOCK_CANRetryGet_CALL_INSTANCE* cmock_call_instance, uint32 ui32Base);
void CMockExpectParameters_CANRetryGet(CMOCK_CANRetryGet_CALL_INSTANCE* cmock_call_instance, uint32 ui32Base)
{
  cmock_call_instance->Expected_ui32Base = ui32Base;
  cmock_call_instance->IgnoreArg_ui32Base = 0;
}

void CANRetryGet_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, boolean cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_CANRetryGet_CALL_INSTANCE));
  CMOCK_CANRetryGet_CALL_INSTANCE* cmock_call_instance = (CMOCK_CANRetryGet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.CANRetryGet_CallInstance = CMock_Guts_MemChain(Mock.CANRetryGet_CallInstance, cmock_guts_index);
  Mock.CANRetryGet_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.CANRetryGet_IgnoreBool = (char)1;
}

void CANRetryGet_CMockStopIgnore(void)
{
  if(Mock.CANRetryGet_IgnoreBool)
    Mock.CANRetryGet_CallInstance = CMock_Guts_MemNext(Mock.CANRetryGet_CallInstance);
  Mock.CANRetryGet_IgnoreBool = (char)0;
}

void CANRetryGet_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, boolean cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_CANRetryGet_CALL_INSTANCE));
  CMOCK_CANRetryGet_CALL_INSTANCE* cmock_call_instance = (CMOCK_CANRetryGet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.CANRetryGet_CallInstance = CMock_Guts_MemChain(Mock.CANRetryGet_CallInstance, cmock_guts_index);
  Mock.CANRetryGet_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void CANRetryGet_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32 ui32Base, boolean cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_CANRetryGet_CALL_INSTANCE));
  CMOCK_CANRetryGet_CALL_INSTANCE* cmock_call_instance = (CMOCK_CANRetryGet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.CANRetryGet_CallInstance = CMock_Guts_MemChain(Mock.CANRetryGet_CallInstance, cmock_guts_index);
  Mock.CANRetryGet_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_CANRetryGet(cmock_call_instance, ui32Base);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(boolean[sizeof(cmock_to_return) == sizeof(boolean) ? 1 : -1])); /* add boolean to :treat_as_array if this causes an error */
}

void CANRetryGet_AddCallback(CMOCK_CANRetryGet_CALLBACK Callback)
{
  Mock.CANRetryGet_IgnoreBool = (char)0;
  Mock.CANRetryGet_CallbackBool = (char)1;
  Mock.CANRetryGet_CallbackFunctionPointer = Callback;
}

void CANRetryGet_Stub(CMOCK_CANRetryGet_CALLBACK Callback)
{
  Mock.CANRetryGet_IgnoreBool = (char)0;
  Mock.CANRetryGet_CallbackBool = (char)0;
  Mock.CANRetryGet_CallbackFunctionPointer = Callback;
}

void CANRetryGet_CMockIgnoreArg_ui32Base(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_CANRetryGet_CALL_INSTANCE* cmock_call_instance = (CMOCK_CANRetryGet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.CANRetryGet_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_ui32Base = 1;
}

void CANRetrySet(uint32 ui32Base, boolean bAutoRetry)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_CANRetrySet_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_CANRetrySet);
  cmock_call_instance = (CMOCK_CANRetrySet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.CANRetrySet_CallInstance);
  Mock.CANRetrySet_CallInstance = CMock_Guts_MemNext(Mock.CANRetrySet_CallInstance);
  if (Mock.CANRetrySet_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.CANRetrySet_CallbackBool &&
      Mock.CANRetrySet_CallbackFunctionPointer != NULL)
  {
    Mock.CANRetrySet_CallbackFunctionPointer(ui32Base, bAutoRetry, Mock.CANRetrySet_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_ui32Base)
  {
    UNITY_SET_DETAILS(CMockString_CANRetrySet,CMockString_ui32Base);
    UNITY_TEST_ASSERT_EQUAL_UINT32(cmock_call_instance->Expected_ui32Base, ui32Base, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_bAutoRetry)
  {
    UNITY_SET_DETAILS(CMockString_CANRetrySet,CMockString_bAutoRetry);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_bAutoRetry), (void*)(&bAutoRetry), sizeof(boolean), cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.CANRetrySet_CallbackFunctionPointer != NULL)
  {
    Mock.CANRetrySet_CallbackFunctionPointer(ui32Base, bAutoRetry, Mock.CANRetrySet_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_CANRetrySet(CMOCK_CANRetrySet_CALL_INSTANCE* cmock_call_instance, uint32 ui32Base, boolean bAutoRetry);
void CMockExpectParameters_CANRetrySet(CMOCK_CANRetrySet_CALL_INSTANCE* cmock_call_instance, uint32 ui32Base, boolean bAutoRetry)
{
  cmock_call_instance->Expected_ui32Base = ui32Base;
  cmock_call_instance->IgnoreArg_ui32Base = 0;
  memcpy((void*)(&cmock_call_instance->Expected_bAutoRetry), (void*)(&bAutoRetry),
         sizeof(boolean[sizeof(bAutoRetry) == sizeof(boolean) ? 1 : -1])); /* add boolean to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_bAutoRetry = 0;
}

void CANRetrySet_CMockIgnore(void)
{
  Mock.CANRetrySet_IgnoreBool = (char)1;
}

void CANRetrySet_CMockStopIgnore(void)
{
  Mock.CANRetrySet_IgnoreBool = (char)0;
}

void CANRetrySet_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_CANRetrySet_CALL_INSTANCE));
  CMOCK_CANRetrySet_CALL_INSTANCE* cmock_call_instance = (CMOCK_CANRetrySet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.CANRetrySet_CallInstance = CMock_Guts_MemChain(Mock.CANRetrySet_CallInstance, cmock_guts_index);
  Mock.CANRetrySet_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void CANRetrySet_CMockExpect(UNITY_LINE_TYPE cmock_line, uint32 ui32Base, boolean bAutoRetry)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_CANRetrySet_CALL_INSTANCE));
  CMOCK_CANRetrySet_CALL_INSTANCE* cmock_call_instance = (CMOCK_CANRetrySet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.CANRetrySet_CallInstance = CMock_Guts_MemChain(Mock.CANRetrySet_CallInstance, cmock_guts_index);
  Mock.CANRetrySet_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_CANRetrySet(cmock_call_instance, ui32Base, bAutoRetry);
}

void CANRetrySet_AddCallback(CMOCK_CANRetrySet_CALLBACK Callback)
{
  Mock.CANRetrySet_IgnoreBool = (char)0;
  Mock.CANRetrySet_CallbackBool = (char)1;
  Mock.CANRetrySet_CallbackFunctionPointer = Callback;
}

void CANRetrySet_Stub(CMOCK_CANRetrySet_CALLBACK Callback)
{
  Mock.CANRetrySet_IgnoreBool = (char)0;
  Mock.CANRetrySet_CallbackBool = (char)0;
  Mock.CANRetrySet_CallbackFunctionPointer = Callback;
}

void CANRetrySet_CMockIgnoreArg_ui32Base(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_CANRetrySet_CALL_INSTANCE* cmock_call_instance = (CMOCK_CANRetrySet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.CANRetrySet_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_ui32Base = 1;
}

void CANRetrySet_CMockIgnoreArg_bAutoRetry(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_CANRetrySet_CALL_INSTANCE* cmock_call_instance = (CMOCK_CANRetrySet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.CANRetrySet_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_bAutoRetry = 1;
}

uint32 CANStatusGet(uint32 ui32Base, tCANStsReg eStatusReg)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_CANStatusGet_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_CANStatusGet);
  cmock_call_instance = (CMOCK_CANStatusGet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.CANStatusGet_CallInstance);
  Mock.CANStatusGet_CallInstance = CMock_Guts_MemNext(Mock.CANStatusGet_CallInstance);
  if (Mock.CANStatusGet_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.CANStatusGet_FinalReturn;
    Mock.CANStatusGet_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.CANStatusGet_CallbackBool &&
      Mock.CANStatusGet_CallbackFunctionPointer != NULL)
  {
    uint32 cmock_cb_ret = Mock.CANStatusGet_CallbackFunctionPointer(ui32Base, eStatusReg, Mock.CANStatusGet_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_ui32Base)
  {
    UNITY_SET_DETAILS(CMockString_CANStatusGet,CMockString_ui32Base);
    UNITY_TEST_ASSERT_EQUAL_UINT32(cmock_call_instance->Expected_ui32Base, ui32Base, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_eStatusReg)
  {
    UNITY_SET_DETAILS(CMockString_CANStatusGet,CMockString_eStatusReg);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_eStatusReg), (void*)(&eStatusReg), sizeof(tCANStsReg), cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.CANStatusGet_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.CANStatusGet_CallbackFunctionPointer(ui32Base, eStatusReg, Mock.CANStatusGet_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_CANStatusGet(CMOCK_CANStatusGet_CALL_INSTANCE* cmock_call_instance, uint32 ui32Base, tCANStsReg eStatusReg);
void CMockExpectParameters_CANStatusGet(CMOCK_CANStatusGet_CALL_INSTANCE* cmock_call_instance, uint32 ui32Base, tCANStsReg eStatusReg)
{
  cmock_call_instance->Expected_ui32Base = ui32Base;
  cmock_call_instance->IgnoreArg_ui32Base = 0;
  memcpy((void*)(&cmock_call_instance->Expected_eStatusReg), (void*)(&eStatusReg),
         sizeof(tCANStsReg[sizeof(eStatusReg) == sizeof(tCANStsReg) ? 1 : -1])); /* add tCANStsReg to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_eStatusReg = 0;
}

void CANStatusGet_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32 cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_CANStatusGet_CALL_INSTANCE));
  CMOCK_CANStatusGet_CALL_INSTANCE* cmock_call_instance = (CMOCK_CANStatusGet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.CANStatusGet_CallInstance = CMock_Guts_MemChain(Mock.CANStatusGet_CallInstance, cmock_guts_index);
  Mock.CANStatusGet_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.CANStatusGet_IgnoreBool = (char)1;
}

void CANStatusGet_CMockStopIgnore(void)
{
  if(Mock.CANStatusGet_IgnoreBool)
    Mock.CANStatusGet_CallInstance = CMock_Guts_MemNext(Mock.CANStatusGet_CallInstance);
  Mock.CANStatusGet_IgnoreBool = (char)0;
}

void CANStatusGet_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, uint32 cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_CANStatusGet_CALL_INSTANCE));
  CMOCK_CANStatusGet_CALL_INSTANCE* cmock_call_instance = (CMOCK_CANStatusGet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.CANStatusGet_CallInstance = CMock_Guts_MemChain(Mock.CANStatusGet_CallInstance, cmock_guts_index);
  Mock.CANStatusGet_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void CANStatusGet_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32 ui32Base, tCANStsReg eStatusReg, uint32 cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_CANStatusGet_CALL_INSTANCE));
  CMOCK_CANStatusGet_CALL_INSTANCE* cmock_call_instance = (CMOCK_CANStatusGet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.CANStatusGet_CallInstance = CMock_Guts_MemChain(Mock.CANStatusGet_CallInstance, cmock_guts_index);
  Mock.CANStatusGet_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_CANStatusGet(cmock_call_instance, ui32Base, eStatusReg);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void CANStatusGet_AddCallback(CMOCK_CANStatusGet_CALLBACK Callback)
{
  Mock.CANStatusGet_IgnoreBool = (char)0;
  Mock.CANStatusGet_CallbackBool = (char)1;
  Mock.CANStatusGet_CallbackFunctionPointer = Callback;
}

void CANStatusGet_Stub(CMOCK_CANStatusGet_CALLBACK Callback)
{
  Mock.CANStatusGet_IgnoreBool = (char)0;
  Mock.CANStatusGet_CallbackBool = (char)0;
  Mock.CANStatusGet_CallbackFunctionPointer = Callback;
}

void CANStatusGet_CMockIgnoreArg_ui32Base(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_CANStatusGet_CALL_INSTANCE* cmock_call_instance = (CMOCK_CANStatusGet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.CANStatusGet_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_ui32Base = 1;
}

void CANStatusGet_CMockIgnoreArg_eStatusReg(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_CANStatusGet_CALL_INSTANCE* cmock_call_instance = (CMOCK_CANStatusGet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.CANStatusGet_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_eStatusReg = 1;
}

